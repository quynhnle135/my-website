"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8012],{3905:(n,e,r)=>{r.d(e,{Zo:()=>l,kt:()=>v});var i=r(7294);function t(n,e,r){return e in n?Object.defineProperty(n,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[e]=r,n}function a(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,i)}return r}function o(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){t(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function d(n,e){if(null==n)return{};var r,i,t=function(n,e){if(null==n)return{};var r,i,t={},a=Object.keys(n);for(i=0;i<a.length;i++)r=a[i],e.indexOf(r)>=0||(t[r]=n[r]);return t}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)r=a[i],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(n,r)&&(t[r]=n[r])}return t}var c=i.createContext({}),s=function(n){var e=i.useContext(c),r=e;return n&&(r="function"==typeof n?n(e):o(o({},e),n)),r},l=function(n){var e=s(n.components);return i.createElement(c.Provider,{value:e},n.children)},p="mdxType",u={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},f=i.forwardRef((function(n,e){var r=n.components,t=n.mdxType,a=n.originalType,c=n.parentName,l=d(n,["components","mdxType","originalType","parentName"]),p=s(r),f=t,v=p["".concat(c,".").concat(f)]||p[f]||u[f]||a;return r?i.createElement(v,o(o({ref:e},l),{},{components:r})):i.createElement(v,o({ref:e},l))}));function v(n,e){var r=arguments,t=e&&e.mdxType;if("string"==typeof n||t){var a=r.length,o=new Array(a);o[0]=f;var d={};for(var c in e)hasOwnProperty.call(e,c)&&(d[c]=e[c]);d.originalType=n,d[p]="string"==typeof n?n:t,o[1]=d;for(var s=2;s<a;s++)o[s]=r[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,r)}f.displayName="MDXCreateElement"},8190:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>d,toc:()=>s});var i=r(7462),t=(r(7294),r(3905));const a={title:"Oct 3"},o=void 0,d={unversionedId:"coding-journal/2023/October/oct_03_23",id:"coding-journal/2023/October/oct_03_23",title:"Oct 3",description:"BFS review",source:"@site/docs/coding-journal/2023/10 - October/oct_03_23.md",sourceDirName:"coding-journal/2023/10 - October",slug:"/coding-journal/2023/October/oct_03_23",permalink:"/my-website/docs/coding-journal/2023/October/oct_03_23",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/coding-journal/2023/10 - October/oct_03_23.md",tags:[],version:"current",frontMatter:{title:"Oct 3"},sidebar:"tutorialSidebar",previous:{title:"Oct 2",permalink:"/my-website/docs/coding-journal/2023/October/oct_02_23"},next:{title:"Oct 4",permalink:"/my-website/docs/coding-journal/2023/October/oct_04_23"}},c={},s=[{value:"BFS review",id:"bfs-review",level:3},{value:"DFS review",id:"dfs-review",level:3},{value:"Number of Islands review (solved in BFS way)",id:"number-of-islands-review-solved-in-bfs-way",level:3},{value:"Number of Islands review (solved in DFS way)",id:"number-of-islands-review-solved-in-dfs-way",level:3},{value:"Number of Provinces (applied BFS)",id:"number-of-provinces-applied-bfs",level:3},{value:"Transitive closure",id:"transitive-closure",level:3},{value:"Detect cycle in a directed graph",id:"detect-cycle-in-a-directed-graph",level:3}],l={toc:s},p="wrapper";function u(n){let{components:e,...r}=n;return(0,t.kt)(p,(0,i.Z)({},l,r,{components:e,mdxType:"MDXLayout"}),(0,t.kt)("h3",{id:"bfs-review"},"BFS review"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def BFS(graph):\n    queue = []\n    visited = set()\n    result = []\n    for vertex in graph:\n        if vertex not in visited:\n            queue.append(vertex)\n            while queue:\n                node = queue.pop(0)\n                if node not in visited:\n                    visited.add(node)\n                    result.append(node)\n                    for neighbor in graph[node]:\n                        if neighbor not in visited:\n                            queue.append(neighbor)\n    return result\n\n\ndef main():\n    g = {\n        "A": ["B", "C"],\n        "B": ["D"],\n        "C": ["E", "F"],\n        "D": [],\n        "E": ["F"],\n        "F": []\n    }\n    print(BFS(g))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,t.kt)("h3",{id:"dfs-review"},"DFS review"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def DFS(graph):\n    stack = []\n    visited = set()\n    result = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.add(node)\n                    result.append(node)\n                    for neighbor in graph[vertex]:\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n    return result\n\n\ndef main():\n    graph1 = {\n        "A": ["B"],\n        "B": ["C"],\n        "C": ["D"],\n        "D": ["E"],\n        "E": []\n    }\n\n    graph2 = {\n        "A": ["B", "C"],\n        "B": ["D", "E", "F"],\n        "C": [],\n        "D": [],\n        "E": ["G"],\n        "F": [],\n        "G": []\n    }\n\n    print(DFS(graph1))\n    print(DFS(graph2))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,t.kt)("h3",{id:"number-of-islands-review-solved-in-bfs-way"},"Number of Islands review (solved in BFS way)"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def count_islands(matrix):\n    islands = 0\n    visited = set()\n    queue = []\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            pos = (row, col)\n            if matrix[row][col] == 1 and pos not in visited:\n                queue.append(pos)\n                islands += 1\n                while queue:\n                    node = queue.pop(0)\n                    if node not in visited:\n                        visited.add(node)\n                        check_neighbors(matrix, visited, queue, node)\n    return islands\n\n\ndef check_neighbors(matrix, visited, queue, node):\n    if node[0] < 0 or node[0] > len(matrix) or node[1] < 0 or node[1] > len(matrix[node[0]]) or matrix[node[0]][node[1]] == 0:\n        return\n    up = (node[0] - 1, node[1])\n    down = (node[0] + 1, node[1])\n    left = (node[0], node[1] - 1)\n    right = (node[0], node[1] + 1)\n\n    if 0 <= up[0] < len(matrix):\n        queue.append(up)\n\n    if 0 <= down[0] < len(matrix):\n        queue.append(down)\n\n    if 0 <= left[1] < len(matrix[node[0]]):\n        queue.append(left)\n\n    if 0 <= right[1] < len(matrix[node[0]]):\n        queue.append(right)\n\n\ndef main():\n    graph1 = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 0],\n        [1, 0, 1, 1]\n    ]\n\n    graph2 = [\n        [1, 1, 0, 0],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 1]\n    ]\n\n    print(count_islands(graph1))\n    print(count_islands(graph2))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,t.kt)("h3",{id:"number-of-islands-review-solved-in-dfs-way"},"Number of Islands review (solved in DFS way)"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def count_islands(matrix):\n    islands = 0\n    stack = []\n    visited = set()\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            pos = (row, col)\n            if matrix[row][col] == 1 and pos not in visited:\n                islands += 1\n                stack.append(pos)\n                while stack:\n                    node = stack.pop()\n                    if node not in visited:\n                        visited.add(node)\n                        DFS(matrix, stack, node)\n    return islands\n\n\ndef DFS(matrix, stack, node):\n    if node[0] < 0 or node[0] >= len(matrix) or node[1] < 0 or node[1] >= len(matrix[node[0]]) or matrix[node[0]][node[1]] == 0:\n        return\n    up = (node[0] - 1, node[1])\n    down = (node[0] + 1, node[1])\n    left = (node[0], node[1] - 1)\n    right = (node[0], node[1] + 1)\n\n    if 0 <= up[0] < len(matrix):\n        stack.append(up)\n\n    if 0 <= down[0] < len(matrix):\n        stack.append(down)\n\n    if 0 <= left[1] < len(matrix[node[0]]):\n        stack.append(left)\n\n    if 0 <= right[0] < len(matrix[node[0]]):\n        stack.append(right)\n\n\ndef main():\n    matrix = [\n        [1, 1, 0],\n        [1, 0, 0],\n        [0, 0, 1]\n    ]\n    print(count_islands(matrix))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,t.kt)("h3",{id:"number-of-provinces-applied-bfs"},"Number of Provinces (applied BFS)"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def count_provinces(matrix):\n    provinces = 0\n    n = len(matrix)\n    queue = []\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            provinces += 1\n            queue.append(i)\n            while queue:\n                node = queue.pop(0)\n                if not visited[node]:\n                    visited[node] = True\n                    for j in range(n):\n                        if matrix[node][j] == 1 and not visited[j]:\n                            queue.append(j)\n    return provinces\n\n\ndef main():\n    graph1 = [\n        [1, 1, 0],\n        [0, 1, 1],\n        [0, 0, 1],\n    ]\n    graph2 = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 1]\n    ]\n\n    print(count_provinces(graph1))\n    print(count_provinces(graph2))\n\n\nif __name__ == "__main__":\n    main()\n\n')),(0,t.kt)("h3",{id:"transitive-closure"},"Transitive closure"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def transitive_closure(graph):\n    n = len(graph)\n    tc = [0] * n\n    for i in range(n):\n        tc[i] = graph[i]\n\n    for row in range(n):\n        for col in range(n):\n            if graph[row][col] == 1:\n                check_neighbor(graph, tc, row, col)\n    return tc\n\n\ndef check_neighbor(graph, tc, s, v):\n    tc[s][v] = 1\n    n = len(graph)\n    for row in range(n):\n        for col in range(n):\n            if graph[v][col] == 1 and tc[s][col] == 0:\n                check_neighbor(graph, tc, s, col)\n\n\ndef main():\n    graph1 = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 1]\n    ]\n    print(transitive_closure(graph1))\n    graph2 = [\n        [1, 1, 0, 1],\n        [0, 1, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 0, 1]\n    ]\n    print(transitive_closure(graph2))\n    graph3 = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1]\n    ]\n    print(transitive_closure(graph3))\n\n\nif __name__ == "__main__":\n    main()\n\n')),(0,t.kt)("h3",{id:"detect-cycle-in-a-directed-graph"},"Detect cycle in a directed graph"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def detect_cycle(graph):\n    n = len(graph)\n    visited = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [i]\n        while stack:\n            v = stack[-1]\n            if not visited[v]:\n                visited[v] = True\n            else:\n                stack.pop()\n                continue\n            for j in range(n):\n                if graph[v][j] == 1:\n                    if not visited[j]:\n                        stack.append(j)\n                    elif j in stack:\n                        return True\n    return False\n\n\ndef isCyclic(graph):\n    n = len(graph)\n    visited = [False] * n\n    recStack = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if isCyclicUtil(i, graph, visited, recStack):\n                return True\n    return False\n\n\ndef isCyclicUtil(v, graph, visited, recStack):\n    visited[v] = True\n    recStack[v] = True\n\n    for i in range(len(graph)):\n        if graph[v][i] == 1:\n            if not visited[i]:\n                if isCyclicUtil(i, graph, visited, recStack):\n                    return True\n            elif recStack[i]:\n                return True\n\n    recStack[v] = False\n    return False\n\n\ndef main():\n    matrix1 = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [1, 0, 0, 0],\n        [0, 0, 0, 0]\n    ]\n\n    matrix2 = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n    ]\n\n    print(detect_cycle(matrix1))\n    print(isCyclic(matrix1))\n    print(detect_cycle(matrix2))\n    print(isCyclic(matrix2))\n\n\nif __name__ == "__main__":\n    main()\n')))}u.isMDXComponent=!0}}]);