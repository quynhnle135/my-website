"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2878],{3905:(e,n,r)=>{r.d(n,{Zo:()=>l,kt:()=>f});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function d(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var o=t.createContext({}),p=function(e){var n=t.useContext(o),r=n;return e&&(r="function"==typeof e?e(n):d(d({},n),e)),r},l=function(e){var n=p(e.components);return t.createElement(o.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),c=p(r),u=i,f=c["".concat(o,".").concat(u)]||c[u]||g[u]||a;return r?t.createElement(f,d(d({ref:n},l),{},{components:r})):t.createElement(f,d({ref:n},l))}));function f(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,d=new Array(a);d[0]=u;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[c]="string"==typeof e?e:i,d[1]=s;for(var p=2;p<a;p++)d[p]=r[p];return t.createElement.apply(null,d)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},6320:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var t=r(7462),i=(r(7294),r(3905));const a={title:"Sep 29"},d=void 0,s={unversionedId:"coding-journal/2023/September/sep_29_23",id:"coding-journal/2023/September/sep_29_23",title:"Sep 29",description:"Graph review",source:"@site/docs/coding-journal/2023/September/sep_29_23.md",sourceDirName:"coding-journal/2023/September",slug:"/coding-journal/2023/September/sep_29_23",permalink:"/my-website/docs/coding-journal/2023/September/sep_29_23",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/coding-journal/2023/September/sep_29_23.md",tags:[],version:"current",frontMatter:{title:"Sep 29"},sidebar:"tutorialSidebar",previous:{title:"Sep 28",permalink:"/my-website/docs/coding-journal/2023/September/sep_28_23"},next:{title:"Leetcode Grinding",permalink:"/my-website/docs/category/leetcode-grinding"}},o={},p=[{value:"Graph review",id:"graph-review",level:2},{value:"Print adjacency list for a directed graph",id:"print-adjacency-list-for-a-directed-graph",level:3},{value:"BFS traversal",id:"bfs-traversal",level:3},{value:"DFS traversal",id:"dfs-traversal",level:3},{value:"Notes:",id:"notes",level:4}],l={toc:p},c="wrapper";function g(e){let{components:n,...r}=e;return(0,i.kt)(c,(0,t.Z)({},l,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"graph-review"},"Graph review"),(0,i.kt)("h3",{id:"print-adjacency-list-for-a-directed-graph"},"Print adjacency list for a directed graph"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# My solution\ndef print_list(v, edges):\n    v_dictionary = {}\n    for i in range(len(edges)):\n        source = edges[i]\n        if source[0] in v_dictionary:\n            v_dictionary[source[0]].append(source[1])\n        else:\n            v_dictionary[source[0]] = [source[1]]\n\n    for vertex in range(v):\n        print(vertex, " -> ", end="")\n        for value in v_dictionary[vertex]:\n           print(value, end=" ")\n        print()\n    print()\n\n\n# Geeksforgeeks solution\n# Function to add edges\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n\n\ndef initializeGraph(v, edges, noOfEdges):\n    adj = [0] * v\n    for i in range(v):\n        adj[i] = []\n\n    for i in range(0, noOfEdges):\n        print(adj)\n        addEdge(adj, edges[i][0], edges[i][1])\n\n    adjencyList(adj, v)\n\n\ndef adjencyList(adj, v):\n    for i in range(0, v):\n        print(i, " -> ", end="")\n        for j in adj[i]:\n            print(j, " ", end="")\n        print()\n    print()\n\ndef addEdge_again(adj, u, v):\n    adj[u].append(v)\n\n\ndef adjencyList_again(v, adj):\n    for i in range(v):\n        print(i, " -> ", end="")\n        for j in adj[i]:\n            print(j, " ", end="")\n        print()\n\n\n\ndef initGraph_again(v, edges):\n    adj = [0] * v\n    for i in range(v):\n        adj[i] = []\n\n    for i in range(len(edges)):\n        addEdge_again(adj, edges[i][0], edges[i][1])\n    adjencyList_again(v, adj)\n\n\ndef main():\n    # print_list(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]])\n    # print_list(v=3, edges=[[0, 1], [1, 2], [2, 0]])\n    # initializeGraph(v=3, edges=[[0, 1], [1, 2], [2, 0]], noOfEdges=3)\n    # initializeGraph(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]], noOfEdges=5)\n\n    initGraph_again(v=3, edges=[[0, 1], [1, 2], [2, 0]])\n    print()\n    initGraph_again(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]])\n\n\nif __name__ == "__main__":\n    main()\n\n\n')),(0,i.kt)("h3",{id:"bfs-traversal"},"BFS traversal"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from collections import defaultdict, deque\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    # My solution\n    def breadth_first_search(self, s): # s is starting vertex\n        visited = set()\n        queue = [s]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                print(node, end=" ")\n\n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        print()\n\n    # Geeksforgeeks solution\n    def BFS(self, s):\n        visited = [False] * (max(self.graph) + 1)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            s = queue.pop(0)\n            print(s, end=" ")\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n        print()\n\ndef main():\n    my_graph = Graph()\n    my_graph.addEdge(0, 1)\n    my_graph.addEdge(0, 2)\n    my_graph.addEdge(1, 2)\n    my_graph.addEdge(2, 3)\n    # print(my_graph.graph)\n    my_graph.breadth_first_search(0)\n    my_graph.breadth_first_search(2)\n    my_graph.BFS(0)\n    my_graph.BFS(2)\n\n\nif __name__ == "__main__":\n    main()\n\n')),(0,i.kt)("h3",{id:"dfs-traversal"},"DFS traversal"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def dfs_recursive(graph, start):\n    visited = set()\n    traversal = []\n    return dfs_recursive_helper(visited, graph, start, traversal)\n\n\ndef dfs_recursive_helper(visited, graph, start, traversal):\n    if start not in visited:\n        visited.add(start)\n        traversal.append(start)\n        for neighbor in graph[start]:\n            dfs_recursive_helper(visited, graph, neighbor, traversal)\n    return traversal\n\n\ndef dfs(graph, node):\n    stack = [node]\n    visited = set()\n    traversal = []\n    while stack:\n        current = stack.pop()\n        if current not in visited:\n            visited.add(current)\n            traversal.append(current)\n            for neighbor in reversed(graph[current]):\n                stack.append(neighbor)\n    return traversal\n\n\ndef dfs_again(graph, s):\n    stack = [s]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            print(node, end=" ")\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    print()\n\n\ndef DFS(graph, s):\n    visited = set()\n    DFS_helper(graph, s, visited)\n\n\ndef DFS_helper(graph, s, visited):\n    if s not in visited:\n        visited.add(s)\n        print(s, end=" ")\n        for neighbor in graph[s]:\n            if neighbor not in visited:\n                DFS_helper(graph, neighbor, visited)\n\n\ndef main():\n    graph = {\n        "A": ["B", "C"],\n        "B": ["D", "E"],\n        "C": ["F"],\n        "D": [],\n        "E": ["F"],\n        "F": []\n    }\n\n    # print(dfs_recursive(graph, "A"))\n    # print(dfs(graph, "A"))\n    # dfs_again(graph, \'A\')\n    DFS(graph, "A")\n\n\nif __name__ == "__main__":\n    main()\n')),(0,i.kt)("h4",{id:"notes"},"Notes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Tried to do and understand "Transitive closure of a graphp" and "Number of islands" but couldn\'t get them. Will try again tomorrow')))}g.isMDXComponent=!0}}]);