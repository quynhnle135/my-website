"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8637],{9990:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var s=n(5893),i=n(1151);const r={title:"Nov 28, 2023"},a="Coding Journal: Nov 28, 2023",l={id:"learning-journal/2023/November/20231128",title:"Nov 28, 2023",description:"- Updated the Projects page with more latest projects that I've worked on.",source:"@site/docs/learning-journal/2023/November/20231128.md",sourceDirName:"learning-journal/2023/November",slug:"/learning-journal/2023/November/20231128",permalink:"/docs/learning-journal/2023/November/20231128",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Nov 28, 2023"},sidebar:"tutorialSidebar",previous:{title:"Nov 27, 2023",permalink:"/docs/learning-journal/2023/November/20231127"},next:{title:"Dive Into Design Patterns",permalink:"/docs/category/dive-into-design-patterns"}},d={},o=[{value:"Getting Started",id:"getting-started",level:3},{value:"Key notes in Chapter 1:",id:"key-notes-in-chapter-1",level:3},{value:"<strong>Set up and install pytest</strong>",id:"set-up-and-install-pytest",level:3},{value:"Chapter 2: Writing Test Functions",id:"chapter-2-writing-test-functions",level:3},{value:"Key Notes in Chapter 2:",id:"key-notes-in-chapter-2",level:3}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"coding-journal-nov-28-2023",children:"Coding Journal: Nov 28, 2023"}),"\n",(0,s.jsx)(t.h1,{id:"1-what-i-learned-and-did-today",children:"1. What I Learned and Did Today"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Updated the Projects page with more latest projects that I've worked on."}),"\n",(0,s.jsx)(t.li,{children:"Updated the color theme and logo for my website."}),"\n",(0,s.jsx)(t.li,{children:"Created new folder for Book Reviews."}),"\n",(0,s.jsx)(t.li,{children:"Finished writing tests for my Automate Spotify Playlist project."}),"\n",(0,s.jsxs)(t.li,{children:["Reviewed and tried to thoroughly what I wrote in my test:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"I recalled one thing on my internship that when it comes to testing, you shouldn't only test the function itself by calling but you have to make sure that every other function used in the one your testing has been called successfully as well."}),"\n",(0,s.jsx)(t.li,{children:"When using mock and patch in Python unittest (not Pytest), I find it very similar to the tests I used to write in my internship (using Pytest). Although the tools are different, the logic behind every test is still the same, which I mentioned above that every test should cover all the functions there are in the one we're testing. Mock and patch are necessary since it won't affect and call the APIs."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:"Put Automate Spotify Playlist project on my resume and edited my resume."}),"\n",(0,s.jsx)(t.li,{children:"Practice writing testing with pytest"}),"\n",(0,s.jsx)(t.li,{children:"Took note and wrote code snippet along the reading."}),"\n",(0,s.jsx)(t.li,{children:"Here is what I've learned and reviewed so far:"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"What is pip because I always use pip whenever it comes to install a new package, library, or framework?"})}),"\n",(0,s.jsxs)(t.p,{children:["=> Answer: ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)("mark",{children:"pip is a package management system which is used to install and manage software packages."})})})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"key-notes-in-chapter-1",children:"Key notes in Chapter 1:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"pytest is installed into a virtual environment with the following steps (for Mac):"}),"\n",(0,s.jsx)(t.p,{children:"(*) Disclaimer: I'm using Pycharm and looks like there's already a virtual environment venv set up. However, I can always create a new virtual environment with different name if needed."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"(*) Why do we need virtual environment?"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["=> Answer: ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)("mark",{children:"To keep dependencies required by different projects separated by creating isolated Python environment for them."})})})," For example, there's one project that I need Django and Django framework to work with. However, the other one doesn't require any Django but Spotipy instead. Therefore, it's necessary to create a virtual environment for each project."]}),"\n",(0,s.jsx)(t.h3,{id:"set-up-and-install-pytest",children:(0,s.jsx)(t.strong,{children:"Set up and install pytest"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"python3 -m venv myvenv (your virtual environment's name)"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"source myvenv/bin/activate (activate your virtual environment)"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"pip install pytest (install pytest)"})}),"\n",(0,s.jsxs)(t.p,{children:["(*) ",(0,s.jsx)(t.code,{children:"pytest"})," can be run in several different ways:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pytest"}),": With no argument, pytest searches the local repository and subdirectories for tests."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pytest <filename>"}),": Run the tests in that file."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pytest <filename1> <filename2>"}),": Run tests in multiple files."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pytest <dirname>"}),": Run tests in a particular directory"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["(*) To make sure your tests are being tested and run, ",(0,s.jsx)(t.em,{children:"pay attention to naming convention:"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Test files should be named ",(0,s.jsx)(t.code,{children:"test_<something>.py"})," or ",(0,s.jsx)(t.code,{children:"<something>_test.py"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Test methods or functions should be named ",(0,s.jsx)(t.code,{children:"test_<something>"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Test classes should be ",(0,s.jsx)(t.code,{children:"Test<Something>"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"Code Snippet"})})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def test_passing():\n    assert (1, 2, 3) == (1, 2, 3)\n\n# Make this test fail on purpose\ndef test_failing():\n    assert (1, 2, 3) == (3, 2, 1)\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h3,{id:"chapter-2-writing-test-functions",children:"Chapter 2: Writing Test Functions"}),"\n",(0,s.jsxs)(t.p,{children:["Install ",(0,s.jsx)(t.code,{children:"cards_proj"})," as instructed in the book I encountered some errors while running the tests. At first, I use ",(0,s.jsx)(t.code,{children:"pytest"})," as my command:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The current Python I'm using is Python 3.11.0. However, if I run ",(0,s.jsx)(t.code,{children:"pytest"})," itself only, it will be associated with different Python interpreter than the one I'm using."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["I doubt it happens because of the project structure and try to make it correct, but it still ended up with ",(0,s.jsx)(t.code,{children:"ModuleNotFound error"}),". Although I tried to import the Card class with specific, it couldn't work."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["I changed my command to ",(0,s.jsx)(t.code,{children:"python3 -m pytest"}),"., everything works perfectly. Because ",(0,s.jsx)(t.code,{children:"python3"})," makes sure that all the environment settings and dependencies are taken into account. I'm using Python3 as well so it makes more sense."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"Tests for cards_procj"})})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from cards import Card\n\n\n# Test when create a Card object without giving it any argument.\ndef test_default():\n    c = Card()\n    assert c.summary == None\n    assert c.owner == None\n    assert c.state == "todo"\n    assert c.id == None\n\n\n# Test when creating a Card object with arguments.\ndef test_field_access():\n    c = Card("something", "brian", "todo", 123)\n    assert c.summary == "something"\n    assert c.owner == "brian"\n    assert c.state == "todo"\n    assert c.id == 123\n\n\n# Test if two Card objects with the same attributes are equal or not\ndef test_equality():\n    c1 = Card("something", "brian", "todo", 123)\n    c2 = Card("something", "brian", "todo", 123)\n    assert c1 == c2\n\n\n# Test if two Card objects with the same attributes but different ids are equal or not.\n# Because in Card class, id cannot be compared.\ndef test_equality_with_diff_ids():\n    c1 = Card("something", "brian", "todo", 123)\n    c2 = Card("something", "brian", "todo", 4567)\n    assert c1 == c2\n\n\n# Test if two Cards objects are different if given different attributes\ndef test_inequality():\n    c1 = Card("something", "brian", "todo", 123)\n    c2 = Card("completely different", "okken", "done", 123)\n    assert c1 != c2\n\n\n# Test from_dict() function in Card class\ndef test_from_dict():\n    c1 = Card("something", "brian", "todo", 123)\n    c2_dict = {\n        "summary": "something",\n        "owner": "brian",\n        "state": "todo",\n        "id": 123\n    }\n    c2 = Card.from_dict(c2_dict)\n    assert c1 == c2\n\n\n# Test to_dict() function in Card class\ndef test_to_dict():\n    c1 = Card("something", "brian", "todo", 123)\n    c2 = c1.to_dict()\n    c2_expected = {\n        "summary": "something",\n        "owner": "brian",\n        "state": "todo",\n        "id": 123\n    }\n    assert c2 == c2_expected\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"One thing about pytest is its assert statements are different from unittest's:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"assert something"})," is ",(0,s.jsx)(t.code,{children:"assertTrue(something)"})," in unittest"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"assert not something"})," is ",(0,s.jsx)(t.code,{children:"assertFlase(something)"})," in unittest"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"assert a == b"})," is ",(0,s.jsx)(t.code,{children:"assertEqual(a, b)"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"assert a != b"})," is ",(0,s.jsx)(t.code,{children:"assertNotEqual(a, b)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Moreover, you can run ",(0,s.jsx)(t.code,{children:"python3 -m pytest --vv"})," to show more details if your test fails."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["(*) Failing with ",(0,s.jsx)(t.code,{children:"pytest.fail()"})," and Exceptions:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Basically for this section, it tells you that if you want to add comments to explain how this test fail or you can expect this test is failed and want to explain the reason while running your test, you can use ",(0,s.jsx)(t.code,{children:"pytest.fail()"})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import pytest\nfrom cards import Card\n\n\ndef test_with_fail():\n    c1 = Card("sit down", "brian")\n    c2 = Card("do sonmething", "okken")\n    if c1 != c2:\n        pytest.fail("they don\'t match")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["=> For the test above, I know that c1 and c2 will be different because their first arguments are different. Adding ",(0,s.jsx)(t.code,{children:"pytest.fail()"}),' tell me "they don\'t match" in the short test summary: ',(0,s.jsx)(t.code,{children:"FAILED test_alt_"}),(0,s.jsx)(t.a,{href:"http://fail.py",children:(0,s.jsx)(t.code,{children:"fail.py"})}),(0,s.jsx)(t.code,{children:"::test_with_fail - Failed: they don't match"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["You use ",(0,s.jsx)(t.code,{children:"pytest.raises()"})," to test for expected exceptions."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import cards\nimport pytest\n\n\ndef test_no_path_raises():\n    with pytest.raises(TypeError):\n        cards.CardsDB()\n\n\ndef test_raises_with_info():\n    match_regex = "missing 1 .* positional argument"\n    with pytest.raises(TypeError, match=match_regex):\n        cards.CardsDB()\n\n\ndef test_raises_with_info_alt():\n    with pytest.raises(TypeError) as exc_info:\n        cards.CardsDB()\n    expected = "missing 1 required argument"\n    assert expected in str(exc_info.value)\n'})}),"\n",(0,s.jsx)(t.p,{children:"(*) Structuring Test Functions: Arrange-Act-Assert"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Arrange: get ready to something"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Act: do something"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Assert: check to see if it worked"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from cards import Card\n\n\ndef test_to_dict():\n    # Arrange a Card object with known content\n    c1 = Card("something", "brian", "todo", 123)\n    # Act by calling to_dict() function with c1 object and assign it to c2\n    c2 = c1.to_dict()\n    expected_result = {\n        "summary": "something",\n        "owner": "brian",\n        "state": "todo",\n        "id": 123\n    }\n    # Assert: check if they are equal\n    assert c2 == expected_result\n'})}),"\n",(0,s.jsx)(t.h3,{id:"key-notes-in-chapter-2",children:"Key Notes in Chapter 2:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Tests can fail from assertion failures, from calls to fail(), or from any uncaught exception"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pytest.raises()"})," is used to test for expected exceptiojns"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"A great way to structure tests is called Given-When-Then or Arrange-Act-Assert"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Running small subsets of tests is handy while debugging, and pytest allows you to run a small batch of tests in many ways:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Single test method: ",(0,s.jsx)(t.code,{children:"python3 -m pytest path/test_module::TestClass::test_method"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["All tests in a class: ",(0,s.jsx)(t.code,{children:"python3 -m pytest path/test_module::TestClass"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"the -vv command-line flag shows even more information during test failures."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Chapter 3: pytest Fixtures"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"pytest run fixtures first before your real tests because fixtures are used to get a data set for the tests to work on."}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"2-questions-i-have",children:"2. Questions I Have"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"What are fixtures and why do we need it?"}),"\n",(0,s.jsx)(t.li,{children:"What is mock and patch and why do we need it?"}),"\n",(0,s.jsx)(t.li,{children:"Why do we need mock test when it comes to testing the API?"}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"3-what-i-found-challenging",children:"3. What I Found Challenging"}),"\n",(0,s.jsx)(t.h1,{id:"4-code-i-wrote-today",children:"4. Code I Wrote Today"}),"\n",(0,s.jsx)(t.p,{children:"Added this function to test out playlist_items function"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def view_playlist_tracks(playlist_id):\n    playlist_tracks = sp.playlist_items(playlist_id=playlist_id)\n    for tracks in playlist_tracks["items"]:\n        track = tracks["track"]\n        print("Name:", track["name"])\n        print("Album:", track["album"]["name"])\n        print("Artist:", track["artists"][0]["name"])\n        print("*")\n    return playlist_tracks\n'})}),"\n",(0,s.jsx)(t.p,{children:"Tests I Added to my Automate Spotify Playlist project"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'@patch(\'automate_spotify.sp.playlist_add_items\')\n    def test_add_songs_to_playlist(self, mock_playlist_add_items):\n        mock_playlist_add_items_data = {"snapshot_id": "mock snapshot_id"}\n        mock_playlist_add_items.return_value = mock_playlist_add_items_data\n\n        with patch("builtins.print") as mock_print:\n            playlist = add_songs_to_playlist(playlist_id="mock playlist_id",items=["songs"])\n        mock_print.assert_any_call("Songs have been added to the playlist.")\n        mock_playlist_add_items.assert_called_with(playlist_id="mock playlist_id",items=["songs"])\n        self.assertEqual(playlist, mock_playlist_add_items_data)\n\n    @patch(\'automate_spotify.sp.playlist_add_items\')\n    @patch(\'automate_spotify.sp.playlist_items\')\n    def test_add_songs_from_daylist_playlist(self, mock_playlist_items, mock_playlist_add_items):\n        # Mock data for playlist_items response\n        mock_weekly_tracks_data = {\n            "items": [\n                {"track": {"id": "track1_id"}},\n                {"track": {"id": "track2_id"}}\n            ]\n        }\n        mock_playlist_items.return_value = mock_weekly_tracks_data\n\n        # Mock data for playlist_add_items response\n        mock_add_items_response = "Mocked add items response"\n        mock_playlist_add_items.return_value = mock_add_items_response\n\n        # The playlist ID to add songs to\n        test_playlist_id = "test_playlist_id"\n\n        # Mocking the print function\n        with patch("builtins.print") as mock_print:\n            response = add_songs_from_daylist_playlist(playlist_id=test_playlist_id)\n\n        # Assert playlist_items was called correctly\n        mock_playlist_items.assert_called_once_with(\n            playlist_id="https://open.spotify.com/playlist/37i9dQZF1EP6YuccBxUcC1?si=f5d4859eafbd461c")\n\n        # Assert playlist_add_items was called with extracted track IDs\n        mock_playlist_add_items.assert_called_once_with(playlist_id=test_playlist_id, items=["track1_id", "track2_id"])\n\n        # Assert correct print statement\n        mock_print.assert_called_once_with("All songs from current Day List Playlist have been added.")\n\n        # Assert the correct response is returned\n        self.assertEqual(response, mock_add_items_response)\n\n    @patch(\'automate_spotify.sp.playlist_add_items\')\n    @patch(\'automate_spotify.sp.playlist_items\')\n    def test_add_songs_from_weekly_playlist(self, mock_playlist_items, mock_playlist_add_items):\n        # Mock data for playlist_items response\n        mock_weekly_tracks_data = {\n            "items": [\n                {"track": {"id": "track1_id"}},\n                {"track": {"id": "track2_id"}}\n            ]\n        }\n        mock_playlist_items.return_value = mock_weekly_tracks_data\n\n        # Mock data for playlist_add_items response\n        mock_add_items_response = "Mocked add items response"\n        mock_playlist_add_items.return_value = mock_add_items_response\n\n        # The playlist ID to add songs to\n        test_playlist_id = "test_playlist_id"\n\n        # Mocking the print function\n        with patch("builtins.print") as mock_print:\n            response = add_songs_from_weekly_playlist(playlist_id=test_playlist_id)\n\n        # Assert playlist_items was called correctly\n        mock_playlist_items.assert_called_once_with(\n            playlist_id="https://open.spotify.com/playlist/37i9dQZEVXcSl5JcFboUlo")\n\n        # Assert playlist_add_items was called with extracted track IDs\n        mock_playlist_add_items.assert_called_once_with(playlist_id=test_playlist_id, items=["track1_id", "track2_id"])\n\n        # Assert correct print statement\n        mock_print.assert_called_once_with("All songs from this week Discover Weekly Playlist have been added.")\n\n        # Assert the correct response is returned\n        self.assertEqual(response, mock_add_items_response)\n\n    @patch(\'automate_spotify.sp.playlist_items\')\n    def test_view_playlist_tracks(self, mock_playlist_items):\n        mock_playlist_items_data = {\n            "items": [\n                {"track": {\n                    "name": "track 1",\n                    "album": {"name": "album 1"},\n                    "artists": [{"name": "artist 1"}]\n                }}\n            ]\n        }\n        mock_playlist_items.return_value = mock_playlist_items_data\n        with patch("builtins.print") as mock_print:\n            playlist_tracks = view_playlist_tracks(playlist_id ="mock playlist_id")\n        mock_print.assert_any_call("Name:", "track 1")\n        mock_print.assert_any_call("Album:", "album 1")\n        mock_print.assert_any_call("Artist:", "artist 1")\n        mock_playlist_items.assert_called_with(playlist_id="mock playlist_id")\n        self.assertEqual(playlist_tracks, mock_playlist_items_data)\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>a});var s=n(7294);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);