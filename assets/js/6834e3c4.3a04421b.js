"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[880],{3905:(n,e,t)=>{t.d(e,{Zo:()=>p,kt:()=>h});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var c=r.createContext({}),u=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},p=function(n){var e=u(n.components);return r.createElement(c.Provider,{value:e},n.children)},s="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,o=n.originalType,c=n.parentName,p=l(n,["components","mdxType","originalType","parentName"]),s=u(t),d=a,h=s["".concat(c,".").concat(d)]||s[d]||m[d]||o;return t?r.createElement(h,i(i({ref:e},p),{},{components:t})):r.createElement(h,i({ref:e},p))}));function h(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var c in e)hasOwnProperty.call(e,c)&&(l[c]=e[c]);l.originalType=n,l[s]="string"==typeof n?n:a,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3944:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=t(7462),a=(t(7294),t(3905));const o={title:"Apr 29",description:"Coding Journal - Sat, Apr 29",tags:["journal"]},i=void 0,l={unversionedId:"coding-journal/2023/April/apr_29_23",id:"coding-journal/2023/April/apr_29_23",title:"Apr 29",description:"Coding Journal - Sat, Apr 29",source:"@site/docs/coding-journal/2023/April/apr_29_23.md",sourceDirName:"coding-journal/2023/April",slug:"/coding-journal/2023/April/apr_29_23",permalink:"/my-website/docs/coding-journal/2023/April/apr_29_23",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/coding-journal/2023/April/apr_29_23.md",tags:[{label:"journal",permalink:"/my-website/docs/tags/journal"}],version:"current",frontMatter:{title:"Apr 29",description:"Coding Journal - Sat, Apr 29",tags:["journal"]},sidebar:"tutorialSidebar",previous:{title:"Apr 28",permalink:"/my-website/docs/coding-journal/2023/April/apr_28_23"},next:{title:"Apr 30",permalink:"/my-website/docs/coding-journal/2023/April/apr_30_23"}},c={},u=[],p={toc:u},s="wrapper";function m(n){let{components:e,...t}=n;return(0,a.kt)(s,(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Informative and easy-to-understand article about Recursion in Python: ",(0,a.kt)("a",{parentName:"p",href:"https://samuell.hashnode.dev/recursion-with-python-a-beginner-guide-on-recursion"},"https://samuell.hashnode.dev/recursion-with-python-a-beginner-guide-on-recursion")),(0,a.kt)("p",null,"Git Pull Request:"),(0,a.kt)("p",null,"git branch: to check which branch that I'm currently on"),(0,a.kt)("p",null,"git checkout branch name: to be on that branch"),(0,a.kt)("p",null,"git branch branch name: create new branch"),(0,a.kt)("p",null,"git add . : add all changes and updates that I'm working on the branch"),(0,a.kt)("p",null,"git commit -m : commit my changes with comment"),(0,a.kt)("p",null,"git push --set-upstream origin branch name: push my code on the new branch I just created"),(0,a.kt)("p",null,"Decimal number: base 10 system"),(0,a.kt)("p",null,"Binary number: base 2 system"),(0,a.kt)("p",null,"Octal number: base 8 system"),(0,a.kt)("p",null,"Hexadecimal number: hex = 6 and decimal = 10 -> base 16 system"),(0,a.kt)("p",null,"Hexadecimal number:"),(0,a.kt)("p",null,"0 = 0, 1 = 1...9 = 9, 10 = A, 11 = B, 12 = C, 13 = D, 14 = E, 15 = F"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Convert to decimal number to binary number:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# 12 is 1100 in binary\n# explanation:\n# 12 % 2 == 0 -> 12 // 2 = 6\n# 6 % 2 == 0 -> 6 // 2 = 3\n# 3 % 2 == 1 -> 3 // 2 = 1\n# 1 % 2 == 1 -> 1 // 2 = 0\n\n# another example:\n# 7 is 111\n# 7 % 2 == 1 -> 7 // 2 = 3\n# 3 % 2 == 1 -> 3 // 2 = 1\n# 1 % 2 == 1 -> 1 // 2 = 0\n\ndef convert_to_binary(num):\n# base case: return 0 when num is 0\n    if num == 0:\n        return 0\n    return (num % 2) + (10 * convert_to_binary(num // 2))\n\ndef convert_to_binary_iterative(num):\n    binary = 0\n    stack = []\n    while num > 0:\n        # get remainder\n        remainder = num % 2\n        # divide current number with 2\n        num //= 2\n        # push remainder to the stack\n        stack.append(remainder)\n    while stack:\n        binary = binary * 10 + stack.pop()\n    return binary\n")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"print(convert_to_binary(7))\nprint(convert_to_binary_iterative(7))\nprint(convert_to_binary(12))\nprint(convert_to_binary_iterative(12))\n```\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Convert decimal number to octal number:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# example: 1792 -> 3400\n# 1792 % 8 = 0 -> 1792 // 8 = 224\n# 224 % 8 = 0 -> 224 // 8 = 28\n# 28 % 8 = 4 -> 28 // 8 = 3\n# 3 % 8 = 3 -> 3 // 8 = 0\n\ndef convert_to_octal(num):\n    # base case: return 0 when num is 0\n    if num == 0:\n        return 0\n    return num % 8 + 10 * convert_to_octal(num // 8)\n")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"def convert_to_octal_iterative(num):\n    stack = []\n    octal = 0\n    while num > 0:\n        # get remainder of 8\n        remainder = num % 8\n        # push the remainder to the stack\n        stack.append(remainder)\n        # divide current number by 8\n        num //= 8\n    while stack:\n        octal = octal * 10 + stack.pop()\n    return octal\n\n\nprint(convert_to_octal(1792))\nprint(convert_to_octal_iterative(1792))\nprint(convert_to_octal(7))\nprint(convert_to_octal_iterative(7))\nprint(convert_to_octal(8))\nprint(convert_to_octal_iterative(8))\nprint(convert_to_octal(42))\nprint(convert_to_octal_iterative(42))\n```\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Generate pascal triangle"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# example: numRows = 3\n`#      1\n#    1   1\n#  1   2   1\n# input: 3\n# output: [[1], [1, 1], [1, 2, 1]]\n\ndef pascal_triangle_iterative(rows):\n    # add the first row to the triangle\n    triangle = [[1]]\n    if rows == 1:\n        return triangle\n\n    for i in range(1, rows):\n        # get the previous row\n        prev_row = triangle[-1]\n        # add the first value to the current row\n        cur_row = [1]\n        for j in range(1, i):\n            cur_row.append(prev_row[j - 1] + prev_row[j])\n        # add the last value to the current row\n        cur_row.append(1)\n        # add the current row to the triangle\n        triangle.append(cur_row)\n    return triangle\n")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"def pascal_triangle(rows):\n    # base case if there's no row, return empty list\n    if rows == 0:\n        return []\n    # base case: if row = 1, return [[1]]\n    if rows == 1:\n        return [[1]]\n\n    cur_row = [1]\n    # recursively call the function\n    result = pascal_triangle(rows - 1)\n    # get the previous row by accessing the last value in triangle\n    prev_row = result[-1]\n    # calculating the value in the middle of the current row\n    for i in range(1, len(prev_row)):\n        num = prev_row[i] + prev_row[i - 1]\n        cur_row.append(num)\n    # add the last value to the current row\n    cur_row.append(1)\n    # add the current row to the triangle\n    result.append(cur_row)\n\n    return result\n\n\nprint(pascal_triangle_iterative(3))\nprint(pascal_triangle(3))\nprint(pascal_triangle_iterative(5))\nprint(pascal_triangle(5))`\n```\n")),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Count substring:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},'def count_substring(s, sub_str):\n    if len(s) == 0 or len(s) < len(sub_str):\n        return 0\n    # get the length of sub string\n    n = len(sub_str)\n    # if found substring in current string, add 1 and call the function recursively\n    if s[0:n] == sub_str:\n        # trim the first char of current string to continue checking substring\n        return count_substring(s[1:], sub_str) + 1\n    # if not found, continue with the next char of the current string\n    return count_substring(s[1:], sub_str)\n\nprint(count_substring(s="helloleetcodehelloleetcodehello", sub_str="hello"))\nprint(count_substring(s="helloleetcodehelloleetcodehello", sub_str="leetcode"))\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Find permutations:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},'def permutations(word):\n    # base case\n    if len(word) == 1:\n        return [word]\n    # call the function but start with the second character of the current string\n    perms = permutations(word[1:])\n    # get the first character of the current string\n    char = word[0]\n    result = []\n\n    for perm in perms:\n        for i in range(len(perm) + 1):\n            result.append(perm[:i] + char + perm[i:])\n\n    return result\n\nprint(permutations("abc"))\nprint(permutations("abcd"))\n')))))}m.isMDXComponent=!0}}]);