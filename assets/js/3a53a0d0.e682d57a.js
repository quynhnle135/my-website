"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8042],{1762:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var t=r(5893),o=r(1151);const i={title:"Mar 05, 2024"},l="Coding Journal: Mar 04, 2024",s={id:"learning-journal/2024/March/20240305",title:"Mar 05, 2024",description:"- Continued with Data Structures for Coding Interview in JavaScript (Tree/BST review and Graph):",source:"@site/docs/learning-journal/2024/March/20240305.md",sourceDirName:"learning-journal/2024/March",slug:"/learning-journal/2024/March/20240305",permalink:"/docs/learning-journal/2024/March/20240305",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Mar 05, 2024"},sidebar:"tutorialSidebar",previous:{title:"Mar 04, 2024",permalink:"/docs/learning-journal/2024/March/20240304"},next:{title:"Mar 25, 2024",permalink:"/docs/learning-journal/2024/March/20240325"}},a={},d=[{value:"Validate BST",id:"validate-bst",level:4},{value:"Same Tree",id:"same-tree",level:4},{value:"Symetric Tree",id:"symetric-tree",level:4},{value:"Number of connected components of undirected graph",id:"number-of-connected-components-of-undirected-graph",level:4},{value:"Minimum number of vertices to reach all nodes",id:"minimum-number-of-vertices-to-reach-all-nodes",level:4},{value:"Check if path exists in a graph",id:"check-if-path-exists-in-a-graph",level:4}];function c(e){const n={code:"code",h1:"h1",h4:"h4",li:"li",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"coding-journal-mar-04-2024",children:"Coding Journal: Mar 04, 2024"}),"\n",(0,t.jsx)(n.h1,{id:"1-what-i-learned-and-did-today",children:"1. What I Learned and Did Today"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Continued with Data Structures for Coding Interview in JavaScript (Tree/BST review and Graph):","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Tree/BST review:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Validate BST"}),"\n",(0,t.jsx)(n.li,{children:"Same Tree"}),"\n",(0,t.jsx)(n.li,{children:"Symetric Tree"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Graph:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Number of connected components of undirected graph"}),"\n",(0,t.jsx)(n.li,{children:"Minimum number of vertices to reach all nodes"}),"\n",(0,t.jsx)(n.li,{children:"Check if path exists in a graph"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"2-questions-i-had-today",children:"2. Questions I Had Today"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"I didn't have any question for today."}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"3-what-i-found-challenging-today",children:"3. What I Found Challenging Today"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Convert edges list to adjacency list."}),"\n",(0,t.jsx)(n.li,{children:"Union & Find in Graph."}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"4-code-i-wrote-today",children:"4. Code I Wrote Today"}),"\n",(0,t.jsx)(n.h4,{id:"validate-bst",children:"Validate BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { BST } from "./BST.js";\n// Applied In-order Traversal\nfunction validateBST(root) {\n    let traversal = inOrderTraversal(root, []);\n    for (let i = 1; i < traversal.length; i++) {\n        if (traversal[i - 1] >= traversal[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction inOrderTraversal(node, traversal) {\n    if (node) {\n        inOrderTraversal(node.left, traversal);\n        traversal.push(node.val);\n        inOrderTraversal(node.right, traversal);\n    }\n    return traversal;\n}\n\n// Validate BST recursively\nfunction validateBinarySearchTree(root) {\n    return helper(root, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n}\n\nfunction helper(node, low, high) {\n    if (node === null) {\n        return true;\n    }\n    if (node.val <= low || node.val >= high) return false;\n    return helper(node.left, low, node.val) && helper(node.right, node.val, high);\n}\n\nlet bst = new BST(10);\nbst.insert(7);\nbst.insert(12);\nbst.insert(5);\nbst.insert(15);\nbst.insert(11);\nbst.insert(8);\n\nconsole.log(validateBST(bst.root)); // true\nconsole.log(validateBinarySearchTree(bst.root)); // true\n'})}),"\n",(0,t.jsx)(n.h4,{id:"same-tree",children:"Same Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n// Applied In-order Traversal\nfunction sameTreeIOT(root1, root2) {\n    let traversal1 = inOrderTraversal(root1, []);\n    let traversal2 = inOrderTraversal(root2, []);\n    if (traversal1.length !== traversal2.length) return false;\n    for (let i = 0; i < traversal1.length; i++) {\n        if (traversal1[i] !== traversal2[i]) return false;\n    }\n    return true;\n}\n\nfunction inOrderTraversal(node, traversal) {\n    if (node === null) {\n        traversal.push(null);\n    }\n    if (node) {\n        inOrderTraversal(node.left, traversal);\n        traversal.push(node.val);\n        inOrderTraversal(node.right, traversal);\n    }\n    return traversal;\n}\n\n// Check same trees recursively\nfunction sameTree(root1, root2) {\n    if (root1 === null && root2 === null) return true;\n    if (root1 === null || root2 === null) return false;\n    if (root1.val !== root2.val) return false;\n    return sameTree(root1.left, root2.left) && sameTree(root1.right, root2.right);\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\n\nlet root2 = new TreeNode(1);\nroot2.left = new TreeNode(2);\nroot2.right = new TreeNode(2);\n\nconsole.log(sameTree(root1, root2));\nconsole.log(sameTreeIOT(root1, root2));\n"})}),"\n",(0,t.jsx)(n.h4,{id:"symetric-tree",children:"Symetric Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n// Recursive solution\nfunction isSymetricTree(root) {\n    return helper(root, root);\n}\n\nfunction helper(node1, node2) {\n    if (node1 === null && node2 === null) return true;\n    if (node1 === null || node2 === null) return false;\n    return (node1.val === node2.val) && helper(node1.right, node2.left) && helper(node1.left, node2.right);\n}\n\n// Iterative solution\nfunction isSymetricTreeIteratively(root) {\n    if (root === null) return true;\n    let cur = root;\n    let queue = [cur, cur];\n    while (queue.length !== 0) {\n        let node1 = queue.shift();\n        let node2 = queue.shift();\n        if (node1 === null && node2 === null) return true;\n        if (node1 === null || node2 === null || node1.val !== node2.val) return false;\n        queue.push(node1.left, node2.right);\n        queue.push(node1.right, node2.left);\n    }\n}\n\n\nlet root = new TreeNode(1)\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\nroot.right.right = new TreeNode(3);\n\nconsole.log(isSymetricTree(root)); // true\nconsole.log(isSymetricTreeIteratively(root)); \n\nroot.right.left = new TreeNode(3);\nroot.right.right = new TreeNode(4);\n\nconsole.log(isSymetricTree(root)); // false\nconsole.log(isSymetricTreeIteratively(root));\n"})}),"\n",(0,t.jsx)(n.h4,{id:"number-of-connected-components-of-undirected-graph",children:"Number of connected components of undirected graph"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function numberOfConnectedComponents(n, edges) {\n    // Convert Edge List to Adjacency List\n    let adjacency_list = [];\n    for (let i = 0; i < n; i++) {\n        adjacency_list.push([]);\n    }\n\n    for (let i = 0; i < edges.length; i++) {\n        let source = edges[i][0];\n        let destination = edges[i][1];\n        adjacency_list[source].push(destination);\n        adjacency_list[destination].push(source);\n    }\n    // console.log("ADJ LIST: " + adjacency_list);\n\n    let visited = new Set();\n    let components = 0;\n    for (let vertex = 0; vertex < n; vertex++) {\n        if (!visited.has(vertex)) {\n            checkNeighbors(vertex, visited, adjacency_list);\n            components++;\n        }\n    }\n    return components;\n}\n\nfunction checkNeighbors(vertex, visited, adjacency_list) {\n    visited.add(vertex);\n    for (let neighbor of adjacency_list[vertex]) {\n        if (!visited.has(neighbor)) {\n            checkNeighbors(neighbor, visited, adjacency_list);\n        }\n    }\n}\n\nlet n = 5;\nlet edges = [[0,1],[1,2],[3,4]];\n\nconsole.log(numberOfConnectedComponents(n, edges)); // 2\n\nn = 5;\nedges = [[0,1],[1,2],[2,3],[3,4]];\nconsole.log(numberOfConnectedComponents(n, edges)); // 1\n\nn = 2;\nedges = [[1,0]];\nconsole.log(numberOfConnectedComponents(n, edges)); // 1\n\nn = 3;\nedges = [[1, 0]];\nconsole.log(numberOfConnectedComponents(n, edges)); // 2\n'})}),"\n",(0,t.jsx)(n.h4,{id:"minimum-number-of-vertices-to-reach-all-nodes",children:"Minimum number of vertices to reach all nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function minimumNumberOfVertices(n, edges) {\n    // Convert edge list to adjacency list\n    let adj_list = [];\n    let minVertices = [];\n    for (let i = 0; i < n; i++) {\n        adj_list[i] = 0;\n    }\n    for (let edge of edges) {\n        let destination = edge[1];\n        adj_list[destination]++;\n    }\n    for (let i = 0; i < adj_list.length; i++) {\n        if (adj_list[i] === 0) {\n            minVertices.push(i);\n        }\n    }\n    return minVertices;\n}\nlet n = 6;\nlet edges = [[0,1],[0,2],[2,5],[3,4],[4,2]];\nconsole.log(minimumNumberOfVertices(n, edges)); // [0, 3]\n\nn = 5;\nedges = [[0,1],[2,1],[3,1],[1,4],[2,4]];\nconsole.log(minimumNumberOfVertices(n, edges)); // [0, 2, 3]\n\n// let myArr = new Array(5);\n// console.log(myArr);\n// console.log(myArr.length);\n// for (let i = 1; i <= 5; i++) {\n//     myArr.push(i);\n// }\n// console.log(myArr);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"check-if-path-exists-in-a-graph",children:"Check if path exists in a graph"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function checkPathDFS(n, edges, source, destination) {\n    if (source === destination) return true;\n   // Convert to adjacency list\n    let adj_list = [];\n    for (let i = 0; i < n; i++) {\n        adj_list.push([]);\n    };\n\n    for (let i = 0; i < edges.length; i++) {\n        let from = edges[i][0];\n        let to = edges[i][1];\n        adj_list[from].push(to);\n        adj_list[to].push(from);\n    }\n    // console.log(adj_list);\n    let visited = new Set();\n\n    function DFS(vertex) {\n        if (vertex === destination) return true;\n        visited.add(vertex);\n        for (let neighbor of adj_list[vertex]) {\n            if (!visited.has(neighbor) && DFS(neighbor) === true) return true;\n        }\n        return false;\n    }\n    return DFS(source, destination, visited, adj_list)\n}\n\nlet n = 3;\nlet edges = [[0,1],[1,2],[2,0]];\nlet source = 0;\nlet destination = 2\nconsole.log(checkPathDFS(n, edges, source, destination)); // true\n\nn = 6;\nedges = [[0,1],[0,2],[3,5],[5,4],[4,3]];\nsource = 0;\ndestination = 5;\nconsole.log(checkPathDFS(n, edges, source, destination)); // false\n\n\nn = 1;\nedges = [[]];\nsource = 0;\ndestination = 0;\nconsole.log(checkPathDFS(n, edges, source, destination)); // true\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>l});var t=r(7294);const o={},i=t.createContext(o);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);