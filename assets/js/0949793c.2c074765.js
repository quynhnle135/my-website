"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1079],{3927:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=r(5893),i=r(1151);const a={title:"Oct 9"},s=void 0,o={id:"learning-journal/2023/October/oct_09_23",title:"Oct 9",description:"Transitive Closure review (DFS)",source:"@site/docs/learning-journal/2023/October/oct_09_23.md",sourceDirName:"learning-journal/2023/October",slug:"/learning-journal/2023/October/oct_09_23",permalink:"/my-website/docs/learning-journal/2023/October/oct_09_23",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Oct 9"},sidebar:"tutorialSidebar",previous:{title:"Oct 7",permalink:"/my-website/docs/learning-journal/2023/October/oct_07_23"},next:{title:"Oct 18",permalink:"/my-website/docs/learning-journal/2023/October/oct_18_23"}},l={},c=[{value:"Transitive Closure review (DFS)",id:"transitive-closure-review-dfs",level:3},{value:"Detect cycle",id:"detect-cycle",level:3},{value:"Notes:",id:"notes",level:4},{value:"Course schedule",id:"course-schedule",level:3},{value:"Notes:",id:"notes-1",level:4},{value:"Practice with enumerate and for loop in 2D array",id:"practice-with-enumerate-and-for-loop-in-2d-array",level:5},{value:"Pramp back-to-back interview",id:"pramp-back-to-back-interview",level:4},{value:"My solution",id:"my-solution",level:4},{value:"Design Hashmap",id:"design-hashmap",level:3},{value:"Notes:",id:"notes-2",level:4}];function u(n){const e={a:"a",code:"code",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h3,{id:"transitive-closure-review-dfs",children:"Transitive Closure review (DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'\ndef transitive_closure(matrix):\n    tc = [0] * len(matrix)\n    for row in range(len(matrix)):\n        tc[row] = matrix[row]\n\n    for row in range(len(tc)):\n        for col in range(len(tc[row])):\n            if tc[row][col] == 1:\n                check_neighbors(row, col, tc, matrix)\n    return tc\n\n\ndef check_neighbors(row, col, tc, matrix):\n    tc[row][col] = 1\n    for i in range(len(tc)):\n        if matrix[col][i] == 1 and tc[row][i] == 0:\n            tc[row][i] = 1\n\n\ndef main():\n    g1 = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    print(transitive_closure(g1))\n\n    g2 = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    print(transitive_closure(g2))\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,t.jsx)(e.h3,{id:"detect-cycle",children:"Detect cycle"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'def detectCycle(graph):\n    n = len(graph)\n    visited = [False] * n\n    curStack = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if checkPath(i, visited, curStack, graph):\n                return True\n    return False\n\n\ndef checkPath(v, visited, curStack, graph):\n    visited[v] = True\n    curStack[v] = True\n\n    for i in range(len(graph)):\n        if graph[v][i] == 1:\n            if not visited[i]:\n                if checkPath(i, visited, curStack, graph):\n                    return True\n            else:\n                return True\n    # curStack[v] = False\n    return False\n\n\ndef main():\n    g1 = [\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 0, 0]\n    ]\n\n    g2 = [\n        [0, 1, 0],\n        [0, 0, 1],\n        [0, 0, 0]\n    ]\n\n    g3 = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    print(detectCycle(g1))\n    print(detectCycle(g2))\n    print(detectCycle(g3))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(e.h4,{id:"notes",children:"Notes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"I don't understand why we need curStack to keep track. When I included curStack and update it after I'm done, it still return the wrong answer. Will look at it and other solutions to solve Detect Cycle problem"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"course-schedule",children:"Course schedule"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'def canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    for u, v in prerequisites:\n        print(u, v)\n        graph[v].append(u)\n    print(graph)\n    status = [0] * numCourses\n\n    def dfs(node):\n        if status[node] == 1:\n            return False\n        if status[node] == 2:\n            return True\n\n        status[node] = 1\n        for neighbor in graph[node]:\n            if not dfs(neighbor):\n                return False\n        status[node] = 2\n        return True\n\n    for i in range(numCourses):\n        if status[i] == 0:\n            if not dfs(i):\n                return False\n    return True\n\n\ndef main():\n    print(canFinish(3, [[1, 0], [0, 1], [2, 1]]))\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,t.jsx)(e.h4,{id:"notes-1",children:"Notes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Can get to know how enumarate and for loop in 2D array works"}),"\n",(0,t.jsx)(e.li,{children:'I find this exercise pretty similar to the detect cycle one. Marking one as we are visited that course then we continue visiting the "neighbor" courses.'}),"\n",(0,t.jsx)(e.li,{children:"Basically, we need to check each course using the for loop in range(numCourses). If one course needs another course as prerequisite, we need to check the other courses if it needs other prerequisites as well. If we encounter the one we're checking, return False (like the current path)"}),"\n"]}),"\n",(0,t.jsx)(e.h5,{id:"practice-with-enumerate-and-for-loop-in-2d-array",children:"Practice with enumerate and for loop in 2D array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'my_list = [10, 20, 30, 40, 50]\n\nfor index, value in enumerate(my_list):\n    print(index, ": ", value)\nprint("---")\n\nprerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]\n\nfor index, l in enumerate(prerequisites):\n    print(index, ": ", l)\n\nprint("---")\n\nfor first, second in prerequisites:\n    print(first, second)\n\n'})}),"\n",(0,t.jsx)(e.h4,{id:"pramp-back-to-back-interview",children:"Pramp back-to-back interview"}),"\n",(0,t.jsx)(e.p,{children:"Question I asked: Island Count"}),"\n",(0,t.jsx)(e.p,{children:"Question I was asked: Array Quadruplet"}),"\n",(0,t.jsx)(e.h4,{id:"my-solution",children:"My solution"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'def fourSum_brute_force(arr, target):\n    arr.sort()\n    result = []\n    for i in range(len(arr) - 3):\n        for j in range(i + 1, len(arr) - 2):\n            start = j + 1\n            end = len(arr) - 1\n            while start < end:\n                quad = [arr[i], arr[j], arr[start], arr[end]]\n                if (sum(quad) == target) and (quad not in result):\n                    result.append(quad)\n                    start += 1\n                    end -= 1\n                    while start < end and arr[start] == arr[start - 1]:\n                        start += 1\n                    while start < end and arr[end] == arr[end + 1]:\n                        end -= 1\n                elif sum(quad) < target:\n                    start += 1\n                else:\n                    end -= 1\n    return result\n\n\ndef main():\n    nums1 = [1, 0, -1, 0, -2, 2]\n    target1 = 0\n    print(fourSum_brute_force(nums1, target1))\n\n    nums2 = [2, 2, 2, 2, 2]\n    target2 = 8\n    print(fourSum_brute_force(nums2, target2))\n\n    nums3 = [-2, -1, -1, 1, 1, 2, 2]\n    target3 = 0\n    print(fourSum_brute_force(nums3, target3))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"design-hashmap",children:"Design Hashmap"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class MyHashMap(object):\n    def __init__(self):\n        self.map = []\n\n    def put(self, key, value):\n        # If current hash map is empty, append right ahead\n        if not self.map:\n            self.map.append([key, value])\n\n        # updated = False\n        # Check if there\'s existing key\n        for pair in self.map:\n            if key == pair[0]:\n                # updated = True\n                pair[1] = value\n                return\n\n        self.map.append([key, value])\n\n    def get(self, key):\n        # Check whether current hash map is empty\n        if not self.map:\n            return -1\n\n        for pair in self.map:\n            if key == pair[0]:\n                return pair[1]\n\n        return -1\n\n    def remove(self, key):\n        if not self.map:\n            print("Hash Map is empty")\n            return\n\n        for pair in self.map:\n            if key == pair[0]:\n                self.map.remove(pair)\n                return\n'})}),"\n",(0,t.jsx)(e.h4,{id:"notes-2",children:"Notes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"As I read the solution and some articles, they use hash value and hash function and ListNode to design this. Not thoroughly understand so will do it the first thing tomorrow morning"}),"\n",(0,t.jsxs)(e.li,{children:["Good explanation: ",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=cNWsgbKwwoU&t=811s",children:"https://www.youtube.com/watch?v=cNWsgbKwwoU&t=811s"})]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>o,a:()=>s});var t=r(7294);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);