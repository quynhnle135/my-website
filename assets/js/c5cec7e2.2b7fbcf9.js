"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8590],{2645:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var t=r(5893),i=r(1151);const s={title:"Day 2"},a=void 0,l={id:"daily-practice/leetcode-75/day-2",title:"Day 2",description:"Let's finish Array and String today!!!",source:"@site/docs/daily-practice/leetcode-75/day-2.md",sourceDirName:"daily-practice/leetcode-75",slug:"/daily-practice/leetcode-75/day-2",permalink:"/my-website/docs/daily-practice/leetcode-75/day-2",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Day 2"},sidebar:"tutorialSidebar",previous:{title:"Day 1",permalink:"/my-website/docs/daily-practice/leetcode-75/day-1"},next:{title:"Day3",permalink:"/my-website/docs/daily-practice/leetcode-75/day-3"}},o={},d=[{value:"Let&#39;s finish Array and String today!!!",id:"lets-finish-array-and-string-today",level:2},{value:"1768. Merge Strings Alternately",id:"1768-merge-strings-alternately",level:3},{value:"Kids With the Greatest Number of Candies",id:"kids-with-the-greatest-number-of-candies",level:3},{value:"Can Place Flower",id:"can-place-flower",level:3},{value:"Reverse Vowels of a String",id:"reverse-vowels-of-a-string",level:3},{value:"Reverse Words in a String",id:"reverse-words-in-a-string",level:3},{value:"Product of Array Except Self",id:"product-of-array-except-self",level:3},{value:"Notes:",id:"notes",level:4}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"lets-finish-array-and-string-today",children:"Let's finish Array and String today!!!"}),"\n",(0,t.jsx)(n.h3,{id:"1768-merge-strings-alternately",children:"1768. Merge Strings Alternately"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"There are three ways I can use to solve this problem"}),"\n",(0,t.jsx)(n.li,{children:"The first one is my intuitive thought by connecting the first letters of word1 and word2 to the result string, then  I slice the two words starting from index 1"}),"\n",(0,t.jsx)(n.li,{children:"The second one is a little similar but I use two pointers for two words. I will append the rest of the words to the result if there're any letters left"}),"\n",(0,t.jsx)(n.li,{children:'The third one is very intersting with the use of zip_longest. With this built-in function, we can connect two words alternately with the fillvalue="" which means there\'s no space connecting. However, the result of the zip_longest is a list of tuples. so I have to use a for loop to connect the values.'}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from itertools import zip_longest\n\n\ndef mergeAlternately(word1, word2):\n    result = ""\n    while word1 and word2:\n        result += word1[0] + word2[0]\n        word1 = word1[1:]\n        word2 = word2[1:]\n    while word1:\n        result += word1\n        word1 = ""\n    while word2:\n        result += word2\n        word2 = ""\n    return result\n\n\ndef mergeAlternately_ii(word1, word2):\n    result = []\n    i, j = 0, 0\n    while i < len(word1) and j < len(word2):\n        result.append(word1[i])\n        result.append(word2[j])\n        i += 1\n        j += 1\n    result.extend(word1[i:])\n    result.extend(word2[j:])\n    return "".join(result)\n\n\ndef mergeAlternately_iii(word1, word2):\n    tuples = zip_longest(word1, word2, fillvalue="")\n    res = ""\n    for t in tuples:\n        res += str(t[0]) + str(t[1])\n    return res\n\n\ndef main():\n    print(mergeAlternately("abc", "pqr"))\n    print(mergeAlternately_ii("abc", "pqr"))\n    print(mergeAlternately_iii("abc", "pqr"))\n    print("--")\n    print(mergeAlternately("ab", "pqrs"))\n    print(mergeAlternately_ii("ab", "pqrs"))\n    print(mergeAlternately_iii("ab", "pqrs"))\n    print("--")\n    print(mergeAlternately("abcd", "pq"))\n    print(mergeAlternately_ii("abcd", "pq"))\n    print(mergeAlternately_iii("abcd", "pq"))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"kids-with-the-greatest-number-of-candies",children:"Kids With the Greatest Number of Candies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This can be easily solved by finding the maximum candies value in the array then traversing the array, with every value adding the extraCandies, if that current value is equal to bigger than the maximum candies value, it will be True."}),"\n",(0,t.jsx)(n.li,{children:'The second solution is quite similar, we still need to find the maximum value. Instead of checking the "sum" like the first solution, we just check the result after subtract the current candies from the maximum candies value. If the result is smaller or equal to the extraCandies, return True and vice versa.'}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def kidsWithCandies(candies, extraCandies):\n    max_candies = 0\n    res = []\n    for c in candies:\n        max_candies = max(max_candies, c)\n\n    for c in candies:\n        if c + extraCandies >= max_candies:\n            res.append(True)\n        else:\n            res.append(False)\n    return res\n\n\ndef kidsWithCandies_ii(candies, extraCandies):\n    max_candies = 0\n    for i in range(len(candies)):\n        max_candies = max(max_candies, candies[i])\n\n    for i in range(len(candies)):\n        if max_candies - candies[i] <= extraCandies:\n            candies[i] = True\n        else:\n            candies[i] = False\n    return candies\n\n\ndef main():\n    print(kidsWithCandies([2, 3, 5, 1, 3], 3))\n    print(kidsWithCandies_ii([2, 3, 5, 1, 3], 3))\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"can-place-flower",children:"Can Place Flower"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For the current position in the flowerbed, if the current value is empty, we need to check the left position and the right position to make sure that they are both empty so that we can place a flower."}),"\n",(0,t.jsx)(n.li,{children:"Checking the read ends (i == 0, i == len(flowerbed) - 1) is important as well because if those two spots are empty, we can place our flower as well."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def canPlaceFlowers(flowerbed, n):\n    if n == 0:\n        return True\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0:\n            leftSpot = (i == 0) or (flowerbed[i - 1] == 0)\n            rightSpot = (i == len(flowerbed) - 1) or (flowerbed[i + 1] == 0)\n\n            if leftSpot and rightSpot:\n                count += 1\n                flowerbed[i] = 1\n                if count == n:\n                    return True\n    return False\n\n\ndef main():\n    print(canPlaceFlowers([1, 0, 0, 0, 1], 1))  # True\n    print(canPlaceFlowers([1, 0, 0, 0, 1], 2))  # False\n    print(canPlaceFlowers([1, 0, 0], 1))  # True\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"reverse-vowels-of-a-string",children:"Reverse Vowels of a String"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def reverse_vowels(s):\n    vowels = "aeiouAEIOU"\n    start = 0\n    end = len(s) - 1\n    s = list(s)\n    while start < end:\n        if s[start] in vowels and s[end] in vowels:\n            # Swap\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n        elif s[start] in vowels:\n            end -= 1\n        else:\n            start += 1\n    return "".join(s)\n\n\ndef main():\n    print(reverse_vowels("hello"))\n    print(reverse_vowels("leetcode"))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"reverse-words-in-a-string",children:"Reverse Words in a String"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import re\n\n\ndef reverse_words(s):\n    s = re.sub(" +", " ", s.strip())\n    words = []\n    start = 0\n    res = ""\n    for end in range(len(s)):\n        if s[end] == " ":\n            word = s[start: end]\n            words.append(word)\n            start = end + 1\n\n    # Connect last word\n    words.append(s[start: len(s)])\n\n    # Reverse words\n    for i in range(len(words) - 1, -1, -1):\n        res += words[i] + " "\n\n    return res.strip()\n\n\ndef main():\n    print(reverse_words("the sky is blue"))  # blue is sky the\n    print(reverse_words("    harry    potter"))  # potter harry\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"product-of-array-except-self",children:"Product of Array Except Self"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For this problem, I can learn about the prefix/suffix calculations to solve this problem. However, I still haven't comprehended the prefix/suffix approach, so I'll definitely check out more exercises to practice"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def findProduct_i(nums):\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        cur_product = 1\n        for j in range(len(nums)):\n            if i == j:\n                continue\n            else:\n                cur_product *= nums[j]\n        res[i] = cur_product\n    return res\n\n\ndef findProduct_ii(nums):\n    n = len(nums)\n    pre = [1] * n\n    post = [1] * n\n    res = [1] * n\n    pre_product = 1\n    post_product = 1\n    for i in range(n):\n        pre[i] = pre_product\n        pre_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        post[i] = post_product\n        post_product *= nums[i]\n\n    for i in range(n):\n        res[i] = pre[i] * post[i]\n    return res\n\n\ndef main():\n    nums1 = [1, 2, 3, 4]\n    nums2 = [-1, 1, 0, -3, 3]\n    print(findProduct_i(nums1))\n    print(findProduct_ii(nums1))\n    print(findProduct_i(nums2))\n    print(findProduct_ii(nums2))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(n.h4,{id:"notes",children:"Notes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Haven't able to finish all problems in Array/String. Will finish them all tomorrow"}),"\n",(0,t.jsx)(n.li,{children:"Check out and prefix/suffix calculation approach"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>a});var t=r(7294);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);