"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7014],{7605:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var i=r(5893),t=r(1151);const s={title:"Jan 01, 2024"},a="Coding Journal: Jan 01, 2024",l={id:"learning-journal/2024/January/20240101",title:"Jan 01, 2024",description:"Happy New Year \ud83e\udd73\ud83c\udf8a\ud83c\udf89\ud83c\udf87",source:"@site/docs/learning-journal/2024/January/20240101.md",sourceDirName:"learning-journal/2024/January",slug:"/learning-journal/2024/January/20240101",permalink:"/docs/learning-journal/2024/January/20240101",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Jan 01, 2024"},sidebar:"tutorialSidebar",previous:{title:"Jornals - 2024",permalink:"/docs/category/jornals---2024"},next:{title:"January 02, 2024",permalink:"/docs/learning-journal/2024/January/20240102"}},d={},o=[{value:"Intervals",id:"intervals",level:4},{value:"Graph",id:"graph",level:4}];function p(n){const e={a:"a",code:"code",h1:"h1",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"coding-journal-jan-01-2024",children:"Coding Journal: Jan 01, 2024"}),"\n",(0,i.jsx)(e.p,{children:"Happy New Year \ud83e\udd73\ud83c\udf8a\ud83c\udf89\ud83c\udf87"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h1,{id:"1-what-i-learned-and-did-today",children:"1. What I Learned and Did Today"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Completed Interval category in Leetcode 150:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Summary Ranges"}),"\n",(0,i.jsx)(e.li,{children:"Merge Intervals"}),"\n",(0,i.jsx)(e.li,{children:"Insert Interval"}),"\n",(0,i.jsx)(e.li,{children:"Minimum Number of Arrows to Burst Balloons"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Reviewed and continued with Graph questions in Leetcode 150:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"DFS (recursive and iterative)"}),"\n",(0,i.jsx)(e.li,{children:"BFS (recursive and iterative)"}),"\n",(0,i.jsx)(e.li,{children:"Course Schedule"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"2-questions-i-have",children:"2. Questions I Have"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"I don't have any question for today"}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"3-what-i-found-challenging",children:"3. What I Found Challenging"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"I don't find anything challening today"}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"4-code-i-wrote-today",children:"4. Code I Wrote Today"}),"\n",(0,i.jsx)(e.h4,{id:"intervals",children:"Intervals"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/summary-ranges/?envType=study-plan-v2&envId=top-interview-150",children:"Summary Ranges"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        res = []\n        end = nums[0]\n        start = nums[0]\n        for num in nums[1:]:\n            if num == end + 1:\n                end = num\n            else:\n                if start == end:\n                    res.append(str(end))\n                else:\n                    res.append(f"{start}->{end}")\n                start = num\n                end = num\n        if start == end:\n            res.append(str(end))\n        else:\n            res.append(f"{start}->{end}")\n        return res\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/merge-intervals/?envType=study-plan-v2&envId=top-interview-150",children:"Merge Intervals"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        for interval in intervals[1:]:\n            last = merged[-1]\n            if interval[0] <= last[1]:\n                last[0] = min(last[0], interval[0])\n                last[1] = max(last[1], interval[1])\n            else:\n                merged.append(interval)\n        return merged\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150",children:"Insert Interal"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n        for interval in intervals:\n            cur_start = interval[0]\n            cur_end = interval[1]\n            new_start = newInterval[0]\n            new_end = newInterval[1]\n\n            if new_end < cur_start:\n                res.append(newInterval)\n                newInterval = interval\n            elif new_start > cur_end:\n                res.append(interval)\n            else:\n                newInterval[0] = min(cur_start, new_start)\n                newInterval[1] = max(cur_end, new_end)\n        res.append(newInterval)\n        return res\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/?envType=study-plan-v2&envId=top-interview-150",children:"Minimum Number of Arrows to Burst Baloons"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from typing import List\n\n\n# Apply Interval approach\ndef find_min_arrow_shots(points: List[List[int]]) -> int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[0])\n    arrows = 1\n    cur_end = points[0][1]\n    for interval in points[1:]:\n        if interval[0] <= cur_end:\n            cur_end = min(cur_end, interval[1])\n        else:\n            arrows += 1\n            cur_end = interval[1]\n    return arrows\n\n\n# Apply Greedy approach\ndef find_min_arrow_shots_i(points: List[List[int]]) -> int:\n    points.sort(key=lambda x: x[1])\n    end = points[0][1]\n    arrows = 1\n    for balloon in points[1:]:\n        if balloon[0] > end:\n            end = balloon[1]\n            arrows += 1\n    return arrows\n\n\ndef main():\n    print(find_min_arrow_shots([[10, 16], [2, 8], [1, 6], [7, 12]]))\n    print(find_min_arrow_shots_i([[10, 16], [2, 8], [1, 6], [7, 12]]))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h4,{id:"graph",children:"Graph"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"BFS (recursive and iterative)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def breadth_first_search(graph):\n    visited = []\n    traversal = []\n    queue = []\n    for vertex in graph:\n        if vertex not in visited:\n            queue.append(vertex)\n            bfs(graph, queue, visited, traversal)\n    return traversal\n\n\ndef bfs(graph, queue, visited, traversal):\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.append(node)\n            traversal.append(node)\n            for neighbor in graph[node]:\n                queue.append(neighbor)\n\n\ndef breadth_first_search_iterative(graph):\n    visited = []\n    queue = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            queue.append(vertex)\n            while queue:\n                node = queue.pop(0)\n                if node not in visited:\n                    visited.append(node)\n                    traversal.append(node)\n                    for neighbor in graph[node]:\n                        queue.append(neighbor)\n    return traversal\n\n\ndef main():\n    graph1 = {1: [2, 3], 2: [4], 3: [4], 4: [5], 5: []}\n    graph2 = {"A": ["B", "C"], "B": ["D", "E"], "C": ["F"], "D": [], "E": ["F"], "F": []}\n\n    print(breadth_first_search(graph1))\n    print(breadth_first_search(graph2))\n\n    print(breadth_first_search_iterative(graph1))\n    print(breadth_first_search_iterative(graph2))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"DFS (recursive and iterative)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def depth_first_search(graph):\n    visited = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            visited.append(vertex)\n            traversal.append(vertex)\n            for neighbors in graph[vertex]:\n                dfs(graph, neighbors, visited, traversal)\n    return traversal\n\n\ndef dfs(graph, vertex, visited, traversal):\n    if vertex not in visited:\n        visited.append(vertex)\n        traversal.append(vertex)\n        for neighbors in graph[vertex]:\n            dfs(graph, neighbors, visited, traversal)\n\n\ndef depth_first_search_iterative(graph):\n    visited = []\n    stack = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.append(node)\n                    traversal.append(node)\n                    for neighbors in graph[node]:\n                        stack.append(neighbors)\n    return traversal\n\n\ndef main():\n    graph1 = {1: [2, 3], 2: [4], 3: [4], 4: [5], 5: []}\n    graph2 = {"A": ["B", "C"], "B": ["D", "E"], "C": ["F"], "D": [], "E": ["F"], "F": []}\n\n    print(depth_first_search(graph1))\n    print(depth_first_search_iterative(graph1))\n    print(depth_first_search(graph2))\n    print(depth_first_search_iterative(graph2))\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150",children:"Course Schedule"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from typing import List\n\n\ndef can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool:\n    status = [0] * num_courses\n    graph = [[] for _ in range(num_courses)]\n    for course, pre in prerequisites:\n        graph[pre].append(course)\n\n    for i in range(num_courses):\n        if status[i] == 0:\n            if not check_pre(i, status, graph):\n                return False\n    return True\n\n\ndef check_pre(course, status, graph):\n    if status[course] == 1:\n        return False\n    if status[course] == 2:\n        return True\n    status[course] = 1\n    for i in graph[course]:\n        if not check_pre(i, status, graph):\n            return False\n    status[course] = 2\n    return True\n\n\ndef main():\n    print(can_finish(num_courses=2, prerequisites=[[1, 0]]))  # True\n    print(can_finish(num_courses=2, prerequisites=[[1, 0], [0, 1]]))  # False\n\n\nif __name__ == "__main__":\n    main()\n\n'})})]})}function u(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>l,a:()=>a});var i=r(7294);const t={},s=i.createContext(t);function a(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);