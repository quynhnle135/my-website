"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7639],{8133:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=t(5893),r=t(1151);const a={title:"Dec 31, 2023"},s="Coding Journal: Dec 31, 2023",l={id:"learning-journal/2023/December/20231231",title:"Dec 31, 2023",description:"- Continued with Leetcode 150 (Stack, Interval, and Linked List):",source:"@site/docs/learning-journal/2023/December/20231231.md",sourceDirName:"learning-journal/2023/December",slug:"/learning-journal/2023/December/20231231",permalink:"/docs/learning-journal/2023/December/20231231",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Dec 31, 2023"},sidebar:"tutorialSidebar",previous:{title:"Dec 29, 2023",permalink:"/docs/learning-journal/2023/December/20231229"},next:{title:"Jornals - 2024",permalink:"/docs/category/jornals---2024"}},o={},c=[];function d(n){const e={a:"a",code:"code",h1:"h1",li:"li",pre:"pre",ul:"ul",...(0,r.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"coding-journal-dec-31-2023",children:"Coding Journal: Dec 31, 2023"}),"\n",(0,i.jsx)(e.h1,{id:"1-what-i-learned-and-did-today",children:"1. What I Learned and Did Today"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Continued with Leetcode 150 (Stack, Interval, and Linked List):","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Remove Duplicates from Sorted List"}),"\n",(0,i.jsx)(e.li,{children:"Remove Duplicates from Sorted List II"}),"\n",(0,i.jsx)(e.li,{children:"Simplify Path"}),"\n",(0,i.jsx)(e.li,{children:"Min Stack"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate Reverse Polish Notation"}),"\n",(0,i.jsx)(e.li,{children:"Basic Calculator"}),"\n",(0,i.jsx)(e.li,{children:"Summary Ranges"}),"\n",(0,i.jsx)(e.li,{children:"Merge Intervals"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"2-questions-i-have",children:"2. Questions I Have"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"I don't have any question for today"}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"3-what-i-found-challenging",children:"3. What I Found Challenging"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"I don't find anything challenging for today"}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"4-code-i-wrote-today",children:"4. Code I Wrote Today"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-list/",children:"Remove Duplicates from Sorted List"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n    cur = head\n    while cur.next:\n        if cur.val == cur.next.val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n    return head\n\n# Using Fast and Slow pointers approach\ndef remove_duplicates_i(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n    fast = head\n    slow = head\n    while fast:\n        if fast.val != slow.val:\n            slow.next = fast\n            slow = slow.next\n        fast = fast.next\n    return head\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/",children:"Remove Duplicagtes from Sorted List II"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from listnode import *\nfrom typing import Optional\n\n\ndef remove_duplicates_ii(head):\n    if head is None:\n        return None\n\n    if head.next is None:\n        return head\n\n    cur = head\n    prev = ListNode()\n    prev.next = cur\n    dummy_head = prev\n    while cur and cur.next:\n        if cur.val == cur.next.val:\n            while cur and cur.next and cur.val == cur.next.val:\n                cur = cur.next\n            cur = cur.next\n            prev.next = cur\n        else:\n            prev = cur\n            cur = cur.next\n    return dummy_head.next\n\n\ndef main():\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(2)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(4)\n    print_list(head)\n    new_head = remove_duplicates_ii(head)\n    print_list(head=new_head)\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/simplify-path/description/",children:"Simplify Path"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def simplify_path(path: str) -> str:\n    stack = []\n    path = path.split("/")\n    print(path)\n    for part in path:\n        if part == "..":\n            if stack:\n                stack.pop()\n        elif part and part != ".":\n            stack.append(part)\n    return "/" + "/".join(stack)\n\n\ndef main():\n    print(simplify_path("/home/"))\n    print(simplify_path("/../"))\n    print(simplify_path("/home//foo/"))\n    # print("/home//foo/".split("/"))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/min-stack/",children:"Min Stack"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class MinStack:\n    def __init__(self) -> None:\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        top = self.stack.pop()\n        if top == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def get_min(self) -> int:\n        return self.min_stack[-1]\n\n\ndef main():\n    obj = MinStack()\n    obj.push(-2)\n    obj.push(0)\n    obj.push(-3)\n    print(obj.get_min())  # -3\n    obj.pop()\n    print(obj.stack)\n    print(obj.get_min())  # -2\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/evaluate-reverse-polish-notation/",children:"Evaluate Reverse Polish Notation"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from typing import List\n\n\ndef evaluate_reverse_polish_notation(tokens: List[str]) -> int:\n    stack = []\n    for ch in tokens:\n        if ch in "+-*/":\n            right = stack.pop()\n            left = stack.pop()\n            if ch == "+":\n                cur_val = left + right\n            elif ch == "-":\n                cur_val = left - right\n            elif ch == "*":\n                cur_val = left * right\n            else:\n                cur_val = int(left / right)\n            stack.append(cur_val)\n        else:\n            stack.append(int(ch))\n    return stack[0]\n\n\ndef main():\n    print(evaluate_reverse_polish_notation(tokens=["2", "1", "+", "3", "*"]))  # 9\n    print(evaluate_reverse_polish_notation(tokens=["4", "13", "5", "/", "+"]))  # 6\n    print(evaluate_reverse_polish_notation(tokens=["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]))  # 22\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/basic-calculator/",children:"Basic Calculator"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def calculate(s: str) -> int:\n    stack = []\n    res = 0\n    cur_num = 0\n    operation = 1\n    for ch in s:\n        if ch.isdigit():\n            cur_num += (cur_num * 10) + int(ch)\n        elif ch in "+-":\n            res += operation * cur_num\n            cur_num = 0\n            operation = 1 if ch == "+" else -1\n        elif ch == "(":\n            stack.append(res)\n            stack.append(operation)\n            res = 0\n            cur_num = 0\n            operation = 1\n        elif ch == ")":\n            res += operation * cur_num\n            res *= stack.pop()\n            res += stack.pop()\n            cur_num = 0\n    return res + (operation * cur_num)\n\n\ndef main():\n    print(calculate("1 + 1"))  # 2\n    print(calculate(" 2-1 + 2 "))  # 3\n    print(calculate("(1+(4+5+2)-3)+(6+8)"))  # 23\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/summary-ranges/",children:"Summary Ranges"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from typing import List\n\n\ndef summary_ranges(nums: List[int]) -> List[str]:\n    res = []\n    end = nums[0]\n    start = nums[0]\n    for num in nums[1:]:\n        if num == end + 1:\n            end = num\n        else:\n            if start == end:\n                res.append(str(end))\n            else:\n                interval = f"{start}->{end}"\n                res.append(interval)\n            start = num\n            end = num\n    if start == end:\n        res.append(str(end))\n    else:\n        interval = f"{start}->{end}"\n        res.append(interval)\n    return res\n\n\ndef main():\n    print(summary_ranges([0, 1, 2, 4, 5, 7]))\n    print(summary_ranges([0, 2, 3, 4, 6, 8, 9]))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/merge-intervals/",children:"Merge Intervals"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from typing import List\n\n\ndef merge_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        last = merged[-1]\n        if interval[0] <= last[1]:\n            last[0] = min(last[0], interval[0])\n            last[1] = max(last[1], interval[1])\n        else:\n            merged.append(interval)\n    return merged\n\n\ndef main():\n    print(merge_intervals(intervals=[[1, 3], [2, 6], [8, 10], [15, 18]]))\n    print(merge_intervals(intervals=[[1, 4], [4, 5]]))\n\n\nif __name__ == "__main__":\n    main()\n'})})]})}function p(n={}){const{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},1151:(n,e,t)=>{t.d(e,{Z:()=>l,a:()=>s});var i=t(7294);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);