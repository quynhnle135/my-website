"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[884],{1166:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>r});var i=t(5893),d=t(1151);const s={title:"Day 1"},o=void 0,a={id:"daily-practice/2023/day-1",title:"Day 1",description:"LeetCode 75: Ace Coding Interview with 75 Questions",source:"@site/docs/daily-practice/2023/day-1.md",sourceDirName:"daily-practice/2023",slug:"/daily-practice/2023/day-1",permalink:"/my-website/docs/daily-practice/2023/day-1",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Day 1"},sidebar:"tutorialSidebar",previous:{title:"Leetcode 75",permalink:"/my-website/docs/category/leetcode-75"},next:{title:"Day 2",permalink:"/my-website/docs/daily-practice/2023/day-2"}},l={},r=[{value:"LeetCode 75: Ace Coding Interview with 75 Questions",id:"leetcode-75-ace-coding-interview-with-75-questions",level:2},{value:"Notes:",id:"notes",level:4},{value:"What I did on Day 1?",id:"what-i-did-on-day-1",level:3},{value:"Notes:",id:"notes-1",level:4},{value:"Reverse Linked List",id:"reverse-linked-list",level:5},{value:"Delete the Middle Node of a Linked List",id:"delete-the-middle-node-of-a-linked-list",level:5},{value:"Maximum Twin Sum of a Linked List",id:"maximum-twin-sum-of-a-linked-list",level:5},{value:"Odd Even Linked List",id:"odd-even-linked-list",level:5}];function h(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"leetcode-75-ace-coding-interview-with-75-questions",children:"LeetCode 75: Ace Coding Interview with 75 Questions"}),"\n",(0,i.jsx)(n.h4,{id:"notes",children:"Notes:"}),"\n",(0,i.jsx)(n.p,{children:"- This study plan of Leetcode provides 75 basic and important questions that I should know to prepare for the coding/technical interview.\n- Not only these 75 questions cover the common and essential data structures but also the coding patterns when it comes to coding interviews.\n- I first started this by doing some exercises here and there, jumping around all over. However, I wills stick to each category and try my best to finish it before moving on to the next one.\n- Most of the problems I solve on Day 1 are the ones that I've done before, so that's why I was able to do quite a lot (14 out of 75)"}),"\n",(0,i.jsx)(n.h3,{id:"what-i-did-on-day-1",children:"What I did on Day 1?"}),"\n",(0,i.jsx)(n.p,{children:"- Array/String review:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Merge Strings Alternately"}),"\n",(0,i.jsx)(n.li,{children:"Kids With The Greatest Number of Candies"}),"\n",(0,i.jsx)(n.li,{children:"Can Place Flowers"}),"\n",(0,i.jsx)(n.li,{children:"Reverse Vowels of a String"}),"\n",(0,i.jsx)(n.li,{children:"Reverse Words in a String\n- Two Pointers:"}),"\n",(0,i.jsx)(n.li,{children:"Move Zeroes"}),"\n",(0,i.jsx)(n.li,{children:"Is Subsequence"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"- HashMap/Set:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Find the difference of two arrays"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"- Stack:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Removing Stars From a String"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"- Linked List (Finished)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Delete the Middle Node of a Linked List"}),"\n",(0,i.jsx)(n.li,{children:"Odd Even Linked List"}),"\n",(0,i.jsx)(n.li,{children:"Reverse Linked List"}),"\n",(0,i.jsx)(n.li,{children:"Maximum Twin Sum of a Linked List"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"- Graph - DFS:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Number of Provinces"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"notes-1",children:"Notes:"}),"\n",(0,i.jsx)(n.p,{children:"- Because I'm pretty familiar with Linked List problems on Leetcode and four Linked List problem in this study plan can be easily solved by applying Reverse or Fast and Slow pointers"}),"\n",(0,i.jsx)(n.h5,{id:"reverse-linked-list",children:"Reverse Linked List"}),"\n",(0,i.jsx)(n.p,{children:"- This is the most basic question in Linked List.\n- What I understand is we are basically changing the way ListNode connected to each other. Therefore, we have three pointers to change the connection: prev, cur, and next_node\n- Traverse the linked list one node at a time and update the pointers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef reverse_linkedlist(head):\n    prev = None\n    cur = head\n    while cur:\n        next_node = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next_node\n    return prev\n\n\ndef print_list(head):\n    cur = head\n    while cur.next:\n        print(cur.val, end=" -> ")\n        cur = cur.next\n    print(cur.val, end=" -> null")\n\n\ndef main():\n    h = ListNode(1)\n    h.next = ListNode(2)\n    h.next.next = ListNode(3)\n    h.next.next.next = ListNode(4)\n\n    print_list(head=reverse_linkedlist(h))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h5,{id:"delete-the-middle-node-of-a-linked-list",children:"Delete the Middle Node of a Linked List"}),"\n",(0,i.jsx)(n.p,{children:"- For this problem, we can apply the Fast and Slow pointers approach.\n- By the time the Fast pointer reaches the end of the list, the Slow pointer will reach the middle node. However, because we need to delete the middle node, we need Prev pointer to keep track the one node before the Slow pointer."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef print_list(head):\n    cur = head\n    while cur.next:\n        print(cur.val, end=" -> ")\n        cur = cur.next\n    print(cur.val, end=" -> null")\n    print()\n\n\ndef deleteMiddle(head):\n    if head is None:\n        return None\n\n    if head.next is None:\n        return None\n\n    fast = slow = head\n    prev = ListNode(0, head)\n    dummy_head = prev.next\n\n    # Traverse slow pointer to the middle node\n    while fast and fast.next:\n        fast = fast.next.next\n        prev = slow\n        slow = slow.next\n\n    # Delete the middle node\n    prev.next = prev.next.next\n    return dummy_head\n\n\ndef main():\n    h = ListNode(1)\n    h.next = ListNode(2)\n    h.next.next = ListNode(3)\n    h.next.next.next = ListNode(4)\n    print_list(deleteMiddle(h))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h5,{id:"maximum-twin-sum-of-a-linked-list",children:"Maximum Twin Sum of a Linked List"}),"\n",(0,i.jsx)(n.p,{children:"- To find the twin sum, you need to find the sum of the ith node and the (n - 1 - i)th node.\n- I can solve this problem by reversing the second half of the list, have one pointer at the head of the first half and another one at the head of the reversed second half. Then, we just need to add the value of each node of each half."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef pairSum(head):\n    fast = slow = head\n\n    # Traverse slow pointer to the middle node\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n    # Reverse the second half\n    prev = None\n    while slow:\n        next_node = slow.next\n        slow.next = prev\n        prev = slow\n        slow = next_node\n    slow = prev\n    fast = head\n    max_sum = float("-inf")\n    while fast and slow:\n        cur_sum = fast.val + slow.val\n        max_sum = max(max_sum, cur_sum)\n        fast = fast.next\n        slow = slow.next\n    return max_sum\n\n\ndef main():\n    h = ListNode(5)\n    h.next = ListNode(4)\n    h.next.next = ListNode(2)\n    h.next.next.next = ListNode(1)\n\n    h1 = ListNode(4)\n    h1.next = ListNode(2)\n    h1.next.next = ListNode(2)\n    h1.next.next.next = ListNode(3)\n\n    print(pairSum(h))  # 6\n    print(pairSum(h1))  # 7\n\n\nif __name__ == "__main__":\n    main()\n\n\n'})}),"\n",(0,i.jsx)(n.h5,{id:"odd-even-linked-list",children:"Odd Even Linked List"}),"\n",(0,i.jsx)(n.p,{children:'- The odd and even are based on the "index" of the node. The first node of the list will have index 1 and so on.\n- We can easily solve it by having to pointer. One at the first even index and the other one at the first odd index.\n- The tricky part here is setting the codition for the while loop while connecting the even nodes and odd nodes. However, just by drafting some cases on the paper, I can know that making sure even and even.next is None would work'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef print_list(head):\n    cur = head\n    while cur.next:\n        print(cur.val, end=" -> ")\n        cur = cur.next\n    print(cur.val, end=" -> null")\n    print()\n\n\ndef oddEvenList(head):\n    if not head:\n        return head\n\n    odd = head\n    even = head.next\n    evenHead = even\n\n    while even and even.next:\n        odd.next = odd.next.next\n        even.next = even.next.next\n        odd = odd.next\n        even = even.next\n\n    odd.next = evenHead\n    return head\n\n\ndef main():\n    h = ListNode(1)\n    h.next = ListNode(2)\n    h.next.next = ListNode(3)\n    h.next.next.next = ListNode(4)\n    h.next.next.next.next = ListNode(5)\n\n    print_list(head=h)\n    print_list(head=oddEvenList(h))\n\n\nif __name__ == "__main__":\n    main()\n'})})]})}function c(e={}){const{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(7294);const d={},s=i.createContext(d);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);