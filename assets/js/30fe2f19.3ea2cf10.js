"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6293],{5711:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=r(5893),t=r(1151);const s={title:"Nov 5"},o=void 0,a={id:"daily-practice/2023/November/11_5_23",title:"Nov 5",description:"Depth First Search",source:"@site/docs/daily-practice/2023/November/11_5_23.md",sourceDirName:"daily-practice/2023/November",slug:"/daily-practice/2023/November/11_5_23",permalink:"/my-website/docs/daily-practice/2023/November/11_5_23",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Nov 5"},sidebar:"tutorialSidebar",previous:{title:"Aug 30",permalink:"/my-website/docs/daily-practice/2023/August/aug_30_23"},next:{title:"Sep 04",permalink:"/my-website/docs/daily-practice/2023/September/sep_04_23"}},d={},c=[{value:"Depth First Search",id:"depth-first-search",level:3},{value:"Number of Islands",id:"number-of-islands",level:3},{value:"Number of Provinces",id:"number-of-provinces",level:3}];function l(n){const e={code:"code",h3:"h3",pre:"pre",...(0,t.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h3,{id:"depth-first-search",children:"Depth First Search"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from collections import deque\n\n\ndef dfs(graph, start):\n    return dfs_helper(graph, [start], set(), [])\n\n\ndef dfs_helper(graph, stack, visited, traversal):\n    if not stack:\n        return []\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            traversal.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n                dfs_helper(graph, stack, visited, traversal)\n    return traversal\n\n\ndef dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    traversal = []\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            traversal.append(node)\n\n        for neighbor in reversed(graph[node]):\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return traversal\n\n\ndef depth_first_search(graph):\n    stack = []\n    visited = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    traversal.append(node)\n                    visited.append(node)\n                    for neighbor in graph[node]:\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n    return traversal\n\n\ndef depth_first_search_recursive(graph):\n    visited = []\n    stack = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            depth_first_search_helper(graph, visited, stack, traversal)\n    return traversal\n\n\ndef depth_first_search_helper(graph, visited, stack, traversal):\n    if not stack:\n        return\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.append(node)\n            traversal.append(visited)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n                    depth_first_search_helper(graph, visited, stack, traversal)\n\n\ndef main():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D', 'E'],\n        'C': ['A', 'F'],\n        'D': ['B'],\n        'E': ['B', 'F'],\n        'F': ['C', 'E']\n    }\n    another_graph = {\n        0: [1, 3],\n        1: [0, 2],\n        2: [1, 3],\n        3: [0, 2]\n    }\n\n    print(dfs_iterative(graph, 'A'))\n    print(dfs_iterative(another_graph, 0))\n    print(dfs(graph, 'A'))\n    print(dfs(another_graph, 0))\n\n    print(depth_first_search(graph))\n    print(depth_first_search(another_graph))\n\n\nif __name__ == \"__main__\":\n    main()\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"number-of-islands",children:"Number of Islands"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def number_of_islands(islands):\n    count = 0\n    for row in range(len(islands)):\n        for col in range(len(islands[row])):\n            if islands[row][col] == "1":\n                count += 1\n                dfs(row, col, islands)\n    return count\n\n\ndef dfs(row, col, islands):\n    if row < 0 or row >= len(islands) or col < 0 or col >= len(islands[0]) or islands[row][col] == "0":\n        return\n    islands[row][col] = "0"\n    dfs(row - 1, col, islands)\n    dfs(row + 1, col, islands)\n    dfs(row, col - 1, islands)\n    dfs(row, col + 1, islands)\n\n\ndef count_islands(grid):\n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == "1":\n                count += 1\n                depth_first_search(row, col, grid)\n    return count\n\n\ndef depth_first_search(row, col, grid):\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == "0":\n        return\n\n    grid[row][col] = "0"\n    depth_first_search(row - 1, col, grid)\n    depth_first_search(row + 1, col, grid)\n    depth_first_search(row, col - 1, grid)\n    depth_first_search(row, col + 1, grid)\n\n\ndef main():\n    islands1 = [\n                  ["1", "1", "1", "1", "0"],\n                  ["1", "1", "0", "1", "0"],\n                  ["1", "1", "0", "0", "0"],\n                  ["0", "0", "0", "0", "0"]\n               ]\n    islands2 = [\n                  ["1", "1", "0", "0", "0"],\n                  ["1", "1", "0", "0", "0"],\n                  ["0", "0", "1", "0", "0"],\n                  ["0", "0", "0", "1", "1"]\n               ]\n\n    # print(number_of_islands(islands1))\n    # print(number_of_islands(islands2))\n    print(count_islands(islands1))\n    print(count_islands(islands2))\n\n\nif __name__ == "__main__":\n    main()\n\n\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"number-of-provinces",children:"Number of Provinces"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def count_provinces(isConnected):\n    vertex = [False] * len(isConnected)\n    provinces = 0\n    for i in range(len(isConnected)):\n        if not vertex[i]:\n            provinces += 1\n            check_neighbors(i, vertex, isConnected)\n    return provinces\n\n\ndef check_neighbors(node, vertex, isConnected):\n    vertex[node] = True\n    for i in range(len(isConnected)):\n        if isConnected[node][i] == 1 and not vertex[i]:\n            check_neighbors(i, vertex, isConnected)\n    return\n\n\ndef main():\n    isConnected1 = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]  # 2\n    isConnected2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]  # 3\n\n    print(count_provinces(isConnected1))\n    print(count_provinces(isConnected2))\n\n\nif __name__ == "__main__":\n    main()\n'})})]})}function p(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>a,a:()=>o});var i=r(7294);const t={},s=i.createContext(t);function o(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);