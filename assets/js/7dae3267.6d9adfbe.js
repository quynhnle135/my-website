"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5771],{9227:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>s,toc:()=>l});var i=r(5893),o=r(1151);const t={title:"Oct 10, 2023"},a="Coding Journal: Oct 01, 2023",s={id:"learning-journal/October/20231001",title:"Oct 10, 2023",description:"DFS review",source:"@site/docs/learning-journal/October/20231001.md",sourceDirName:"learning-journal/October",slug:"/learning-journal/October/20231001",permalink:"/docs/learning-journal/October/20231001",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Oct 10, 2023"},sidebar:"tutorialSidebar",previous:{title:"October",permalink:"/docs/category/october"},next:{title:"Oct 02, 2023",permalink:"/docs/learning-journal/October/20231002"}},d={},l=[{value:"DFS review",id:"dfs-review",level:2},{value:"BFS review",id:"bfs-review",level:2},{value:"Number of Islands but based on Node (OOP)",id:"number-of-islands-but-based-on-node-oop",level:2},{value:"Number of Islands using tuples",id:"number-of-islands-using-tuples",level:2},{value:"Transitive closure of a directed graph",id:"transitive-closure-of-a-directed-graph",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",pre:"pre",...(0,o.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"coding-journal-oct-01-2023",children:"Coding Journal: Oct 01, 2023"}),"\n",(0,i.jsx)(e.h2,{id:"dfs-review",children:"DFS review"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def dfs(graph, start):\n    stack = []\n    visited = set()\n    result = []\n\n    stack.append(start)\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n                    dfs(graph, neighbor)\n    return result\n\n\ndef main():\n    graph = {\n        "A": ["B", "C"],\n        "B": ["D"],\n        "C": ["E", "F"],\n        "D": [],\n        "E": ["F"],\n        "F": []\n    }\n\n    print(dfs(graph, "A"))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"bfs-review",children:"BFS review"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def bfs(graph, start):\n    queue = []\n    visited = set()\n    result = []\n    queue.append(start)\n\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return result\n\n\ndef main():\n    graph = {\n        "A": ["B", "C"],\n        "B": ["D"],\n        "C": ["E", "F"],\n        "D": [],\n        "E": ["F"],\n        "F": []\n    }\n\n    print(bfs(graph, "A"))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"number-of-islands-but-based-on-node-oop",children:"Number of Islands but based on Node (OOP)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class Node:\n    def __init__(self, row, col):\n        self.row = row\n        self.col = col\n\n    def __hash__(self):\n        return hash((self.row, self.col))\n\n    def __eq__(self, other):\n        return (self.row == other.row) and (self.col == other.col)\n\n\ndef number_of_islands(matrix):\n    islands = 0\n    queue = []\n    visited = set()\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            node = Node(row, col)\n            if matrix[row][col] == "1" and node not in visited:\n                islands += 1\n                queue.append(node)\n\n                while queue:\n                    cur_node = queue.pop(0)\n                    if cur_node not in visited:\n                        visited.add(cur_node)\n                        find_neighbors(matrix, cur_node, queue)\n\n    return islands\n\n\ndef find_neighbors(matrix, cur_node, queue):\n    if cur_node.row < 0 or cur_node.row >= len(matrix) or cur_node.col < 0 or cur_node.col >= len(matrix[0]) or matrix[cur_node.row][cur_node.col] == "0":\n        return\n\n    up = Node(cur_node.row - 1, cur_node.col)\n    down = Node(cur_node.row + 1, cur_node.col)\n    left = Node(cur_node.row, cur_node.col - 1)\n    right = Node(cur_node.row, cur_node.col + 1)\n\n    if 0 <= down.row < len(matrix):\n        queue.append(down)\n\n    if 0 <= up.row < len(matrix):\n        queue.append(up)\n\n    if 0 <= right.col < len(matrix[0]):\n        queue.append(right)\n\n    if 0 <= left.col < len(matrix[0]):\n        queue.append(left)\n\n\ndef main():\n    grid1 = [\n        ["1", "1", "1", "1", "0"],\n        ["1", "1", "0", "1", "0"],\n        ["1", "1", "0", "0", "0"],\n        ["0", "0", "0", "0", "0"]\n    ]\n\n    grid2 = [\n        ["1", "1", "0", "0", "0"],\n        ["1", "1", "0", "0", "0"],\n        ["0", "0", "1", "0", "0"],\n        ["0", "0", "0", "1", "1"]\n    ]\n\n    print(number_of_islands(grid1))\n    print(number_of_islands(grid2))\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,i.jsx)(e.h2,{id:"number-of-islands-using-tuples",children:"Number of Islands using tuples"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def number_of_islands_dfs(matrix):\n    islands = 0\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            if matrix[row][col] == "1":\n                islands += 1\n                dfs(matrix, row, col)\n    return islands\n\n\ndef dfs(matrix, row, col):\n    if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] == "0":\n        return\n    matrix[row][col] = "0"\n    dfs(matrix, row + 1, col)\n    dfs(matrix, row - 1, col)\n    dfs(matrix, row, col + 1)\n    dfs(matrix, row, col - 1)\n\n\ndef number_of_islands_bfs(matrix):\n    islands = 0\n    queue = []\n    visited = set()\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            if matrix[row][col] == 1:\n                pos = (row, col)\n                if pos not in visited:\n                    islands += 1\n                    queue.append(pos)\n                    while queue:\n                        cur_pos = queue.pop(0)\n                        if cur_pos not in visited:\n                            visited.add(cur_pos)\n                            # checking and adding neighbors\n                            find_neighbors(matrix, cur_pos, queue)\n    return islands\n\n\ndef find_neighbors(matrix, cur_pos, queue):\n    if cur_pos[0] < 0 or cur_pos[0] > len(matrix) or cur_pos[1] < 0 or cur_pos[1] > len(matrix[0]):\n        return\n    up = (cur_pos[0] - 1, cur_pos[1])\n    down = (cur_pos[0] + 1, cur_pos[1])\n    left = (cur_pos[0], cur_pos[1] - 1)\n    right = (cur_pos[0], cur_pos[1] + 1)\n\n    if 0 <= up[0] < len(matrix):\n        queue.append(up)\n\n    if 0 <= down[0] < len(matrix):\n        queue.append(down)\n\n    if 0 <= left[0] < len(matrix[0]):\n        queue.append(left)\n\n    if 0 <= right[0] < len(matrix[0]):\n        queue.append(right)\n\n\ndef main():\n    grid1 = [\n                ["1", "1", "1", "1", "0"],\n                ["1", "1", "0", "1", "0"],\n                ["1", "1", "0", "0", "0"],\n                ["0", "0", "0", "0", "0"]\n            ]\n\n    grid2 = [\n              ["1", "1", "0", "0", "0"],\n              ["1", "1", "0", "0", "0"],\n              ["0", "0", "1", "0", "0"],\n              ["0", "0", "0", "1", "1"]\n            ]\n    print(number_of_islands_dfs(grid1))\n    print(number_of_islands_dfs(grid2))\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"transitive-closure-of-a-directed-graph",children:"Transitive closure of a directed graph"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def transitive_closure_dfs(matrix):\n    tc = [0] * len(matrix)\n    for i in range(len(matrix)):\n        tc[i] = matrix[i]\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 1:\n                dfs(matrix, tc, i, j)\n    print(tc)\n\n\ndef dfs(matrix, tc, s, v):\n    tc[s][v] = 1\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[v][j] == 1 and tc[s][j] == 0:\n                tc[s][j] = 1\n\n\ndef main():\n    graph = [[1, 1, 0, 1],\n             [0, 1, 1, 0],\n             [0, 0, 1, 1],\n             [0, 0, 0, 1]]\n\n    graph2 = [[1, 0, 1, 1],\n              [1, 1, 0, 0],\n              [0, 0, 1, 0],\n              [0, 1, 0, 1]]\n\n    transitive_closure_dfs(graph)\n    transitive_closure_dfs(graph2)\n\n\nif __name__ == "__main__":\n    main()\n'})})]})}function c(n={}){const{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>s,a:()=>a});var i=r(7294);const o={},t=i.createContext(o);function a(n){const e=i.useContext(t);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);