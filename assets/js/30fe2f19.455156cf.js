"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6293],{3905:(n,e,r)=>{r.d(e,{Zo:()=>l,kt:()=>u});var t=r(7294);function i(n,e,r){return e in n?Object.defineProperty(n,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[e]=r,n}function a(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function o(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){i(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function s(n,e){if(null==n)return{};var r,t,i=function(n,e){if(null==n)return{};var r,t,i={},a=Object.keys(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||(i[r]=n[r]);return i}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(n,r)&&(i[r]=n[r])}return i}var d=t.createContext({}),c=function(n){var e=t.useContext(d),r=e;return n&&(r="function"==typeof n?n(e):o(o({},e),n)),r},l=function(n){var e=c(n.components);return t.createElement(d.Provider,{value:e},n.children)},p="mdxType",f={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},h=t.forwardRef((function(n,e){var r=n.components,i=n.mdxType,a=n.originalType,d=n.parentName,l=s(n,["components","mdxType","originalType","parentName"]),p=c(r),h=i,u=p["".concat(d,".").concat(h)]||p[h]||f[h]||a;return r?t.createElement(u,o(o({ref:e},l),{},{components:r})):t.createElement(u,o({ref:e},l))}));function u(n,e){var r=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=r.length,o=new Array(a);o[0]=h;var s={};for(var d in e)hasOwnProperty.call(e,d)&&(s[d]=e[d]);s.originalType=n,s[p]="string"==typeof n?n:i,o[1]=s;for(var c=2;c<a;c++)o[c]=r[c];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},9635:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>f,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var t=r(7462),i=(r(7294),r(3905));const a={title:"Nov 5"},o=void 0,s={unversionedId:"daily-practice/2023/November/11_5_23",id:"daily-practice/2023/November/11_5_23",title:"Nov 5",description:"Depth First Search",source:"@site/docs/daily-practice/2023/November/11_5_23.md",sourceDirName:"daily-practice/2023/November",slug:"/daily-practice/2023/November/11_5_23",permalink:"/my-website/docs/daily-practice/2023/November/11_5_23",draft:!1,tags:[],version:"current",frontMatter:{title:"Nov 5"},sidebar:"tutorialSidebar",previous:{title:"Aug 30",permalink:"/my-website/docs/daily-practice/2023/August/aug_30_23"},next:{title:"Sep 04",permalink:"/my-website/docs/daily-practice/2023/September/sep_04_23"}},d={},c=[{value:"Depth First Search",id:"depth-first-search",level:3},{value:"Number of Islands",id:"number-of-islands",level:3},{value:"Number of Provinces",id:"number-of-provinces",level:3}],l={toc:c},p="wrapper";function f(n){let{components:e,...r}=n;return(0,i.kt)(p,(0,t.Z)({},l,r,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"depth-first-search"},"Depth First Search"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from collections import deque\n\n\ndef dfs(graph, start):\n    return dfs_helper(graph, [start], set(), [])\n\n\ndef dfs_helper(graph, stack, visited, traversal):\n    if not stack:\n        return []\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            traversal.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n                dfs_helper(graph, stack, visited, traversal)\n    return traversal\n\n\ndef dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    traversal = []\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            traversal.append(node)\n\n        for neighbor in reversed(graph[node]):\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return traversal\n\n\ndef depth_first_search(graph):\n    stack = []\n    visited = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    traversal.append(node)\n                    visited.append(node)\n                    for neighbor in graph[node]:\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n    return traversal\n\n\ndef depth_first_search_recursive(graph):\n    visited = []\n    stack = []\n    traversal = []\n    for vertex in graph:\n        if vertex not in visited:\n            stack.append(vertex)\n            depth_first_search_helper(graph, visited, stack, traversal)\n    return traversal\n\n\ndef depth_first_search_helper(graph, visited, stack, traversal):\n    if not stack:\n        return\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.append(node)\n            traversal.append(visited)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n                    depth_first_search_helper(graph, visited, stack, traversal)\n\n\ndef main():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D', 'E'],\n        'C': ['A', 'F'],\n        'D': ['B'],\n        'E': ['B', 'F'],\n        'F': ['C', 'E']\n    }\n    another_graph = {\n        0: [1, 3],\n        1: [0, 2],\n        2: [1, 3],\n        3: [0, 2]\n    }\n\n    print(dfs_iterative(graph, 'A'))\n    print(dfs_iterative(another_graph, 0))\n    print(dfs(graph, 'A'))\n    print(dfs(another_graph, 0))\n\n    print(depth_first_search(graph))\n    print(depth_first_search(another_graph))\n\n\nif __name__ == \"__main__\":\n    main()\n\n")),(0,i.kt)("h3",{id:"number-of-islands"},"Number of Islands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def number_of_islands(islands):\n    count = 0\n    for row in range(len(islands)):\n        for col in range(len(islands[row])):\n            if islands[row][col] == "1":\n                count += 1\n                dfs(row, col, islands)\n    return count\n\n\ndef dfs(row, col, islands):\n    if row < 0 or row >= len(islands) or col < 0 or col >= len(islands[0]) or islands[row][col] == "0":\n        return\n    islands[row][col] = "0"\n    dfs(row - 1, col, islands)\n    dfs(row + 1, col, islands)\n    dfs(row, col - 1, islands)\n    dfs(row, col + 1, islands)\n\n\ndef count_islands(grid):\n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == "1":\n                count += 1\n                depth_first_search(row, col, grid)\n    return count\n\n\ndef depth_first_search(row, col, grid):\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == "0":\n        return\n\n    grid[row][col] = "0"\n    depth_first_search(row - 1, col, grid)\n    depth_first_search(row + 1, col, grid)\n    depth_first_search(row, col - 1, grid)\n    depth_first_search(row, col + 1, grid)\n\n\ndef main():\n    islands1 = [\n                  ["1", "1", "1", "1", "0"],\n                  ["1", "1", "0", "1", "0"],\n                  ["1", "1", "0", "0", "0"],\n                  ["0", "0", "0", "0", "0"]\n               ]\n    islands2 = [\n                  ["1", "1", "0", "0", "0"],\n                  ["1", "1", "0", "0", "0"],\n                  ["0", "0", "1", "0", "0"],\n                  ["0", "0", "0", "1", "1"]\n               ]\n\n    # print(number_of_islands(islands1))\n    # print(number_of_islands(islands2))\n    print(count_islands(islands1))\n    print(count_islands(islands2))\n\n\nif __name__ == "__main__":\n    main()\n\n\n\n')),(0,i.kt)("h3",{id:"number-of-provinces"},"Number of Provinces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def count_provinces(isConnected):\n    vertex = [False] * len(isConnected)\n    provinces = 0\n    for i in range(len(isConnected)):\n        if not vertex[i]:\n            provinces += 1\n            check_neighbors(i, vertex, isConnected)\n    return provinces\n\n\ndef check_neighbors(node, vertex, isConnected):\n    vertex[node] = True\n    for i in range(len(isConnected)):\n        if isConnected[node][i] == 1 and not vertex[i]:\n            check_neighbors(i, vertex, isConnected)\n    return\n\n\ndef main():\n    isConnected1 = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]  # 2\n    isConnected2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]  # 3\n\n    print(count_provinces(isConnected1))\n    print(count_provinces(isConnected2))\n\n\nif __name__ == "__main__":\n    main()\n')))}f.isMDXComponent=!0}}]);