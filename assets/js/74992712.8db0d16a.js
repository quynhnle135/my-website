"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5743],{3905:(n,e,r)=>{r.d(e,{Zo:()=>u,kt:()=>f});var t=r(7294);function i(n,e,r){return e in n?Object.defineProperty(n,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[e]=r,n}function a(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function s(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){i(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function o(n,e){if(null==n)return{};var r,t,i=function(n,e){if(null==n)return{};var r,t,i={},a=Object.keys(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||(i[r]=n[r]);return i}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(n,r)&&(i[r]=n[r])}return i}var c=t.createContext({}),l=function(n){var e=t.useContext(c),r=e;return n&&(r="function"==typeof n?n(e):s(s({},e),n)),r},u=function(n){var e=l(n.components);return t.createElement(c.Provider,{value:e},n.children)},m="mdxType",d={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},p=t.forwardRef((function(n,e){var r=n.components,i=n.mdxType,a=n.originalType,c=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),m=l(r),p=i,f=m["".concat(c,".").concat(p)]||m[p]||d[p]||a;return r?t.createElement(f,s(s({ref:e},u),{},{components:r})):t.createElement(f,s({ref:e},u))}));function f(n,e){var r=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=r.length,s=new Array(a);s[0]=p;var o={};for(var c in e)hasOwnProperty.call(e,c)&&(o[c]=e[c]);o.originalType=n,o[m]="string"==typeof n?n:i,s[1]=o;for(var l=2;l<a;l++)s[l]=r[l];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},912:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=r(7462),i=(r(7294),r(3905));const a={title:"Day3"},s=void 0,o={unversionedId:"leetcode-grinding/leetcode-75/day-3",id:"leetcode-grinding/leetcode-75/day-3",title:"Day3",description:"Finish all exercises in Array/String category",source:"@site/docs/leetcode-grinding/leetcode-75/day-3.md",sourceDirName:"leetcode-grinding/leetcode-75",slug:"/leetcode-grinding/leetcode-75/day-3",permalink:"/my-website/docs/leetcode-grinding/leetcode-75/day-3",draft:!1,tags:[],version:"current",frontMatter:{title:"Day3"},sidebar:"tutorialSidebar",previous:{title:"Day 2",permalink:"/my-website/docs/leetcode-grinding/leetcode-75/day-2"},next:{title:"Day 4",permalink:"/my-website/docs/leetcode-grinding/leetcode-75/day-4"}},c={},l=[{value:"Finish all exercises in Array/String category",id:"finish-all-exercises-in-arraystring-category",level:3},{value:"Greatest Common Divisor of Strings",id:"greatest-common-divisor-of-strings",level:4},{value:"Product of Array Except Self",id:"product-of-array-except-self",level:4},{value:"String Compression",id:"string-compression",level:4},{value:"Increasing Triplet Subsequence",id:"increasing-triplet-subsequence",level:3}],u={toc:l},m="wrapper";function d(n){let{components:e,...r}=n;return(0,i.kt)(m,(0,t.Z)({},u,r,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"finish-all-exercises-in-arraystring-category"},"Finish all exercises in Array/String category"),(0,i.kt)("h4",{id:"greatest-common-divisor-of-strings"},"Greatest Common Divisor of Strings"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"I actually tried to solve this by find the longest common prefix but it didn't work out. Based on the name of the problem, I should do something with the GCD. "),(0,i.kt)("li",{parentName:"ul"},"Using either the math.gcd or implement gcd function are fine. It's better to implement the function yourself (and that's what Leetcode accepts as well)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import math\ndef gcdOfStrings(str1, str2):\n    len1 = len(str1)\n    len2 = len(str2)\n\n    gcd_len = gcd(len1, len2)\n    # print(gcd_len)\n    common_divisor = str1[:gcd_len]\n    if str1 == common_divisor * (len1 // gcd_len) and str2 == common_divisor * (len2 // gcd_len):\n        return common_divisor\n\n    return ""\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef main():\n    print(gcdOfStrings(str1="ABC", str2="ABCABC"))\n    print(gcdOfStrings(str1="ABABAB", str2="ABAB"))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,i.kt)("h4",{id:"product-of-array-except-self"},"Product of Array Except Self"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"With the prefix/suffix approach, we're actually finding all the product before the current index value by going forward and backward. ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def findProduct_i(nums):\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        cur_product = 1\n        for j in range(len(nums)):\n            if i == j:\n                continue\n            else:\n                cur_product *= nums[j]\n        res[i] = cur_product\n    return res\n\n\ndef findProduct_ii(nums):\n    n = len(nums)\n    pre = [1] * n\n    post = [1] * n\n    res = [1] * n\n    pre_product = 1\n    post_product = 1\n    for i in range(n):\n        pre[i] = pre_product\n        pre_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        post[i] = post_product\n        post_product *= nums[i]\n\n    for i in range(n):\n        res[i] = pre[i] * post[i]\n    return res\n\n\ndef main():\n    nums1 = [1, 2, 3, 4]\n    nums2 = [-1, 1, 0, -3, 3]\n    print(findProduct_i(nums1))\n    print(findProduct_ii(nums1))\n    print(findProduct_i(nums2))\n    print(findProduct_ii(nums2))\n\n\nif __name__ == "__main__":\n    main()\n')),(0,i.kt)("h4",{id:"string-compression"},"String Compression"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This exercise confused me a little bit. They want user to update the given chars but also return the len of it as well. The tests cases (expected output) seem wrong and make no sense to me. "),(0,i.kt)("li",{parentName:"ul"},"However, I can learn walker/runner (fast and slow pointers) technique in Array"),(0,i.kt)("li",{parentName:"ul"},"My intuitive thought to solve this problem is using a dictionary to keep track of a letter appearance and append them to the result string. At the end, I just need to return the length of that result string")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def compress_i(chars):\n    char_dict = {}\n    s = ""\n    for char in chars:\n        if char in char_dict:\n            char_dict[char] += 1\n        else:\n            char_dict[char] = 1\n    for c in char_dict:\n        if char_dict[c] == 1:\n            s += c\n        else:\n            s += c + str(char_dict[c])\n    print(s)\n    chars = list(s)\n    print(chars)\n    return len(s)\n\n\ndef compress_ii(chars):\n    runner = 0\n    walker = 0\n    while runner < len(chars):\n        chars[walker] = chars[runner]\n        count = 1\n        while runner + 1 < len(chars) and chars[runner] == chars[runner + 1]:\n            runner += 1\n            count += 1\n\n        if count > 1:\n            for c in str(count):\n                chars[walker + 1] = c\n                walker += 1\n        runner += 1\n        walker += 1\n    return walker\n\n\ndef main():\n    chars1 = ["a","a","b","b","c","c","c"]\n    chars2 = ["a"]\n    chars3 = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]\n    print(compress_i(chars1))  # 6\n    print(compress_i(chars2))  # 1\n    print(compress_i(chars3))  # 4\n\n\nif __name__ == "__main__":\n    main()\n')),(0,i.kt)("h3",{id:"increasing-triplet-subsequence"},"Increasing Triplet Subsequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first solution is simply using nested loops to check the condition, which is not effective since it takes up O(n^3) time complexity"),(0,i.kt)("li",{parentName:"ul"},"The second solution is using maxRight array and minLeft variables to keep track and compare. maxRight array is storing the maximum values before the current index value (but backward)"),(0,i.kt)("li",{parentName:"ul"},"The third solution with first and second variable to keep track of the minimum values are also great. As long first < second < nums, we find the triplet. This reminds me of finding second minimum value problem")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def increasingTriplet_i(nums):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if i == j and i == k:\n                    continue\n                else:\n                    if nums[i] < nums[j] and nums[j] < nums[k]:\n                        return True\n    return False\n\n\ndef increasingTriplet_ii(nums):\n    n = len(nums)\n    maxRight = [0] * n\n    maxRight[-1] = nums[-1]\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], nums[i + 1])\n\n    minLeft = nums[0]\n    for i in range(1, n - 1):\n        if minLeft < nums[i] < maxRight[i]:\n            return True\n        minLeft = min(minLeft, nums[i])\n    return False\n\n\ndef increasingTriplet_iii(nums):\n    first = second = float("inf")\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False\n\n\ndef main():\n    nums1 = [1, 2, 3, 4, 5]\n    nums2 = [5, 4, 3, 2, 1]\n    nums3 = [2, 1, 5, 0, 4, 6]\n\n    print(increasingTriplet_i(nums1))  # True\n    print(increasingTriplet_ii(nums1))\n    print(increasingTriplet_iii(nums1))\n    print(increasingTriplet_i(nums2))  # False\n    print(increasingTriplet_ii(nums2))\n    print(increasingTriplet_iii(nums2))\n    print(increasingTriplet_i(nums3))  # True\n    print(increasingTriplet_ii(nums3))\n    print(increasingTriplet_iii(nums3))\n\n\nif __name__ == "__main__":\n    main()\n')))}d.isMDXComponent=!0}}]);