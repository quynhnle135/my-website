"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4985],{4673:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>d,default:()=>g,frontMatter:()=>t,metadata:()=>s,toc:()=>p});var i=r(5893),a=r(1151);const t={title:"Sep 29, 2023"},d="Coding Journal: Sep 29, 2023",s={id:"learning-journal/September/20230929",title:"Sep 29, 2023",description:"Graph review",source:"@site/docs/learning-journal/September/20230929.md",sourceDirName:"learning-journal/September",slug:"/learning-journal/September/20230929",permalink:"/docs/learning-journal/September/20230929",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Sep 29, 2023"},sidebar:"tutorialSidebar",previous:{title:"Sep 28, 2023",permalink:"/docs/learning-journal/September/20230928"},next:{title:"October",permalink:"/docs/category/october"}},o={},p=[{value:"Graph review",id:"graph-review",level:2},{value:"Print adjacency list for a directed graph",id:"print-adjacency-list-for-a-directed-graph",level:3},{value:"BFS traversal",id:"bfs-traversal",level:3},{value:"DFS traversal",id:"dfs-traversal",level:3},{value:"Notes:",id:"notes",level:4}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",pre:"pre",ul:"ul",...(0,a.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"coding-journal-sep-29-2023",children:"Coding Journal: Sep 29, 2023"}),"\n",(0,i.jsx)(e.h2,{id:"graph-review",children:"Graph review"}),"\n",(0,i.jsx)(e.h3,{id:"print-adjacency-list-for-a-directed-graph",children:"Print adjacency list for a directed graph"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# My solution\ndef print_list(v, edges):\n    v_dictionary = {}\n    for i in range(len(edges)):\n        source = edges[i]\n        if source[0] in v_dictionary:\n            v_dictionary[source[0]].append(source[1])\n        else:\n            v_dictionary[source[0]] = [source[1]]\n\n    for vertex in range(v):\n        print(vertex, " -> ", end="")\n        for value in v_dictionary[vertex]:\n           print(value, end=" ")\n        print()\n    print()\n\n\n# Geeksforgeeks solution\n# Function to add edges\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n\n\ndef initializeGraph(v, edges, noOfEdges):\n    adj = [0] * v\n    for i in range(v):\n        adj[i] = []\n\n    for i in range(0, noOfEdges):\n        print(adj)\n        addEdge(adj, edges[i][0], edges[i][1])\n\n    adjencyList(adj, v)\n\n\ndef adjencyList(adj, v):\n    for i in range(0, v):\n        print(i, " -> ", end="")\n        for j in adj[i]:\n            print(j, " ", end="")\n        print()\n    print()\n\ndef addEdge_again(adj, u, v):\n    adj[u].append(v)\n\n\ndef adjencyList_again(v, adj):\n    for i in range(v):\n        print(i, " -> ", end="")\n        for j in adj[i]:\n            print(j, " ", end="")\n        print()\n\n\n\ndef initGraph_again(v, edges):\n    adj = [0] * v\n    for i in range(v):\n        adj[i] = []\n\n    for i in range(len(edges)):\n        addEdge_again(adj, edges[i][0], edges[i][1])\n    adjencyList_again(v, adj)\n\n\ndef main():\n    # print_list(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]])\n    # print_list(v=3, edges=[[0, 1], [1, 2], [2, 0]])\n    # initializeGraph(v=3, edges=[[0, 1], [1, 2], [2, 0]], noOfEdges=3)\n    # initializeGraph(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]], noOfEdges=5)\n\n    initGraph_again(v=3, edges=[[0, 1], [1, 2], [2, 0]])\n    print()\n    initGraph_again(v=4, edges=[[0, 1], [1, 2], [1, 3], [2, 3], [3, 0]])\n\n\nif __name__ == "__main__":\n    main()\n\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"bfs-traversal",children:"BFS traversal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from collections import defaultdict, deque\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    # My solution\n    def breadth_first_search(self, s): # s is starting vertex\n        visited = set()\n        queue = [s]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                print(node, end=" ")\n\n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        print()\n\n    # Geeksforgeeks solution\n    def BFS(self, s):\n        visited = [False] * (max(self.graph) + 1)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            s = queue.pop(0)\n            print(s, end=" ")\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n        print()\n\ndef main():\n    my_graph = Graph()\n    my_graph.addEdge(0, 1)\n    my_graph.addEdge(0, 2)\n    my_graph.addEdge(1, 2)\n    my_graph.addEdge(2, 3)\n    # print(my_graph.graph)\n    my_graph.breadth_first_search(0)\n    my_graph.breadth_first_search(2)\n    my_graph.BFS(0)\n    my_graph.BFS(2)\n\n\nif __name__ == "__main__":\n    main()\n\n'})}),"\n",(0,i.jsx)(e.h3,{id:"dfs-traversal",children:"DFS traversal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def dfs_recursive(graph, start):\n    visited = set()\n    traversal = []\n    return dfs_recursive_helper(visited, graph, start, traversal)\n\n\ndef dfs_recursive_helper(visited, graph, start, traversal):\n    if start not in visited:\n        visited.add(start)\n        traversal.append(start)\n        for neighbor in graph[start]:\n            dfs_recursive_helper(visited, graph, neighbor, traversal)\n    return traversal\n\n\ndef dfs(graph, node):\n    stack = [node]\n    visited = set()\n    traversal = []\n    while stack:\n        current = stack.pop()\n        if current not in visited:\n            visited.add(current)\n            traversal.append(current)\n            for neighbor in reversed(graph[current]):\n                stack.append(neighbor)\n    return traversal\n\n\ndef dfs_again(graph, s):\n    stack = [s]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            print(node, end=" ")\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    print()\n\n\ndef DFS(graph, s):\n    visited = set()\n    DFS_helper(graph, s, visited)\n\n\ndef DFS_helper(graph, s, visited):\n    if s not in visited:\n        visited.add(s)\n        print(s, end=" ")\n        for neighbor in graph[s]:\n            if neighbor not in visited:\n                DFS_helper(graph, neighbor, visited)\n\n\ndef main():\n    graph = {\n        "A": ["B", "C"],\n        "B": ["D", "E"],\n        "C": ["F"],\n        "D": [],\n        "E": ["F"],\n        "F": []\n    }\n\n    # print(dfs_recursive(graph, "A"))\n    # print(dfs(graph, "A"))\n    # dfs_again(graph, \'A\')\n    DFS(graph, "A")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(e.h4,{id:"notes",children:"Notes:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:'Tried to do and understand "Transitive closure of a graphp" and "Number of islands" but couldn\'t get them. Will try again tomorrow'}),"\n"]})]})}function g(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},1151:(n,e,r)=>{r.d(e,{Z:()=>s,a:()=>d});var i=r(7294);const a={},t=i.createContext(a);function d(n){const e=i.useContext(t);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:d(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);